# 캐시
자주 쓰이는 문서의 사본을 자동으로 보관하는 HTTP장치
웹 요청이 캐시에 도착했을때, 캐시된 로컬 사본이 있다면, 그 문서는 원 서버가 아니라 그 캐시로 부터 제공.

### 캐시의 혜택
1. 불필요 데이터 전송을 줄이기
    -> 똑같은 데이터를 또 받아올 필요가 없어진다.
2. 네트워크 병목 개선
    -> 원격 서버보다 로컬 네트워크가 더 넓은 대역폭을 제공함
    원 서버 요청시의 속도는 그 경로의 가장 느린 네트워크의 속도와 같다.
    로컬 네트워크에서 처리할 수 있다면 처리하는게 좋다. -> 캐시를 도입하면 큰 문서의 경우 성능이 대폭 개선될 수 있다.
3. 원 서버 요청 줄여서 부하 개선(갑작스러운 요청 쇄도 대응)
4. 먼 거리로 인한 지연을 개선
    빛의 속도는 초속 30만km라서 거리에 영향을 받는다.
    거리가 넓어지면 빛의 속도로 인한 지연이 발생한다.

### 캐시 hit,miss
Hit : 요청시 캐시 사본이 있는 경우
Miss : 요청시 캐시 사본이 없는 경우

## HTTP Revalidation
원 서버 콘텐츠는 변경될 수 있기때문에 사본이 여전히 최신인지 서버를 통해 점검해줘야한다.

### When 
언제 검사하는가?
-> 클라이언트가 요청을 했는데, 사본이 검사할 필요가 있을정도로 충분히 오래된 경우


### How

If-Modified-Since : 서버 요청 헤더에 해당 헤더를 추가하면, 캐시된 시간 이후 변경된 경우에만 사본을 보내달라는 의미가 됨

1. 재검사 적중(변경되지 않은 경우)
304 Not Modified. -> 재검사 적중 (느린 적중)

2. 재검사 부적중 (변경된 경우)
200 Ok

3. 객체 삭제
404 Not Found -> 캐시는 사본 삭제

## 캐시 적중률
-> 40%정도면 웹 캐시로 괜찮은 편

### 문서 적중률
얼마나 많은 웹 트랜잭션을 외부로 내보내지 않았는지 보여줌
전체 대기시간이 줄어듦

### 바이트 적중률
캐시를 통해 제고된 모든 바이트의 비율
대역폭 절약을 최적화함

### 클라이언트가 캐시 적중을 확인하는법
응답의 Date 헤더값과 현재 시각을 비교하여, 응답 생성일이 더 오래됐다면 캐시된 것임
또다른 방법은 Age헤더를 사용하는 방법

## 캐시 토폴로지

### Private Cache
개인에게 할당된 캐시
브라우저는 프라이빗 캐시를 내장하고있다.
대부분의 브라우저는 자주 쓰이는 문서를 디스크와 메모리에 캐시한다.

### Public Cache
다수와 공유하는 캐시
공용 프록시 캐시를 말한다.

#### 프록시 캐시 계층
클라이언트 주위에는 작고 저렴한 캐시 사용 (Level 1 cache)
계층 상단에는 많은 사용자들에 의해 공유되는 문서 유지 (Level 2 Cache)

#### 캐시망, 콘텐츠 라우팅, 피어링
캐시망의 프록시 캐시는 소통을 통해 어디로 라우팅할지를 결정한다.
1. URL 근거로 부모캐시와 원서버 동적 선택
2. URL근거 특정 부모 캐시 동적 선택
3. 부모 캐시에게 가기전에 캐시된 사본을 로컬에서 찾아보기
4. 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 허용하되, 캐시를 통한 인터넷 트랜지션은 허용하지 않음

## 캐시 처리 단계

기본 캐시 처리절차
1. 요청 받기
2. 파싱
3. 검색 -> 사본이 있는지 검사, 없다면 받아오기.
    캐시된 객체는 서버 응답 본문과 원서버 응답 헤더를 포함하고 있음
4. 신선도 검사 -> 캐시는 캐시된 사본이 충분히 신선한지 검사, 신선하지 않다면 변경사항이 있는지 서버에게 질의
5. 응답 생성 -> 새로운 헤더와 캐시된 본문으로 응답 메시지 생성
    캐시된 응답 헤더를 토대로 응답 헤더를 생성함.
    캐시는 서버와 클라이언트간에서 헤더를 조정해야함. 캐시 신선도 정보를 삽입해야한다.(Cache-Control, Age, Expires)
    하지만 Date 헤더를 조정해서는 안된다.
6. 발송
7. 로깅
    캐시 적중 통계와 부적중 통계를 기록한다.
    스퀴드 로그 포맷과 넷스케이프 확장 공용 로그 포맷을 많이 사용한다.


## 사본 신선 유지하기
### 문서 만료 
Cache-Control, Expires라는 특별 헤더를 이용해서 원 서버가 각 문서에 유효기간을 붙일 수 있게 해줌
캐시 문서가 만료되기 전에 캐시가 필요하다면 서버 접촉없이 사본을 제공할 수 있음

### 유효기간과 나이
Expires, Cache-Control: max-age 는 동일하나, 절대 시간은 컴퓨터 시계가 올바르게 맞춰져 있을 것을 요구함

1. Cache-Control: max-age
문서의 최대 나이를 정의함
최대 나이는 문서가 처음 생성된 이후부터, 제공하기엔 더 이상 신선하지 않다고 간주될 때까지 경과된 시간의 최대값이다.
Date기준으로 계산

2. Expires
절대 유효기간을 명시함.(유통기한 느낌)
기간이 지났으면, 그 문서는 더이상 신선하지 않음


`만료 != 달라졌다`
검사할 시간이 되었다는 것.
검사 컨텐츠가 바뀌었다면, 새로 받아와서 클라이언트에게 보내줌
안바뀌었다면, 새 만료일을 포함한 새 헤더만 가져와서 캐시안의 헤더를 갱신함

### 조건부 메서드와의 재검사
HTTP는 캐시가 서버에게 조건부 GET을 할 수 있도록 한다.

조건부 GET
1. If-Modified-Since :<date> 
문서가 주어진 날짜 이후로 수정되었다면, 요청 메서드를 처리함
캐시된 버전으로부터 컨텐츠를 변경한 경우에만 컨텐츠를 가져오기 위해 Last-Modified 서버 헤더와 함께 사용됨
변경되지 않은경우 304응답이 옴. 
본문은 보내지 않음.
서버 응답 헤더의 `Last-Modified`헤더와 함께 동작함.
원서버의 최근 변경 일시를 붙임

2. If-None-Match: <age>
서버는 일련번호와 같은 특별한 태그를 제공할 수 있음
If-None-Match 헤더는 캐시된 태그가 서버에 있는 문서의 태그와 다를때만 요청을 처리
    언제씀?
    1. 일정 시간 간격으로 자주 다시쓰여지지만, 내용은 동일한 경우가 있다.
    2. 어떤 변경은, 다시 받아오기에는 사소한 것일 수 있다.
캐시가 객체에 대해 여러개 사본을 가진 경우, 여러개의 엔터티 태그를 포함할 수 있음

### 강한 검사기/약한 검사기
컨텐츠가 조금 변경되었더라도, 그 정도면 같은 것이라고 주장할 수 있도록 하는 `약한 검사기`를 지원함
`w\` 접두어로 약한 검사기를 구분함

## 캐시제어
문서 만료전까지 얼마나 오랫동안 캐시될 수 있게 할것인지 정의함
Cache-Control
### no-store, no-cache
Cache-Control: no-store: 캐시가 사본을 만드는 것을 아예 금지
Cache-Control: no-cache : 로컬 캐시 저장소에 저장되기는 하나, 서버 재검사 없이는 클라이언트에 제공되지 않음

### max-age
Cache-Control: max-age=<second>
신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른 시간. (초단위)
s-maxage: max-age와 비슷하나 public 캐시에만 유효함


### Expires 응답헤더
더 이상 사용하지 않기를 권하는 헤더
초단위 대신 실제 만료 날짜를 명시함. 하지만, 절대 시각은 부정확한 시계에 의해 잘못 동작할 수 있다.

### Must-Revalidate
Cache-Control: must-revalidate
캐시가 이 객체의 신선하지 않은 사본을 원 서버와의 최초의 재검사 없이는 제공해서는 안됨을 의미함

```
Cache-Control: max-age=3600
```

인 경우, 브라우저나 프록시 서버가 끊겼다거나, 성능 최적화를 위해 만료 캐시를 재사용할수도 있음

```
Cache-Control: max-age=3600, must-revalidate
```

하지만 이 경우에는 반드시 확인해야함.
반드시 304를 확인한 뒤에 캐시 사용이 가능해짐


### 휴리스틱 만료
응답이 max-age나 expires중 어떤 것도 포함하지 않는다면,
캐시는 경험적인 방법으로 최대 나이를 계산한다.

LM 알고리즘 
1. 캐시된 문서의 마지막 변경이 상당히 예전이라면, 아마 안정적인 문서일 것이고 갑자기 바뀔일은 별로 없을 것이므로 더 오래 보관해도된다.
2. 만약 캐시된 문서가 최근에 변경되었다면, 그것은 아마 자주 변경될 것이고, 따라서 우리는 그것을 서버와 재검사하기전까지 짧은 기간동안만 캐시해야 한다.

만약, 최근 변경일조자 없다면, 기본 신선도 유지기간을 설정한다.(한시간 or 하루)


### 나이와 신선도 수명

캐시된 사본의 나이와 신선도 수명으로 계산하면된다.
나이보다 신선도 수명이 크면 신선한 것으로 판별

`Age`헤더나 `Date`헤더를 통해 계산해서 나이를 판별해야함

#### Age헤더
객체가 프록시 캐시 내에 머문 초단위 시간

```ts
const 응답_지연_추정값=응답받은시각-요청보낸시각
const 문서_캐시_도착시_나이=보정된_겉보기_나이+응답_지연_추정값
const 사본이_캐시에_머무른_시간=현재시각-응답받은시간

const 나이=문서_캐시_도착시_나이 + 사본이_캐시에_머무른_시간
```

### 겉보기 나이 
모든 컴퓨터가 정확한 시계를 갖고 있다면, 캐시된 문서 나이는 단순히 현재 시간에서 서버가 문서를 보낸 시간을 뺀, 문서의 겉보기 나이가 됨

서버는 단순히 Date헤더 값으로 시간을 보냄
`중요 : 프록시는 Date 헤더를 변경하지 못한다!`
```ts
const 겉보기_나이=응답_받은_시각 - Date헤더값
```

### 클록스큐
두 컴퓨터의 시계설정 차이로 인해 겉보기 나이에 문제가 생기는 것


# 8장 통합점: 게이트웨이, 터널, 릴레이

### 게이트웨이
웹이 복잡해지면서, 모든 리소스를 한 개의 애플리케이션으로만 처리할 수 없다는 것이 분명해졌다.
이에 대한 고안책이 게이트웨이이다.

APP은 게이트웨이에 요청을 보내고, 게이트웨이는 이에 응답한다.

게이트웨이는 HTTP 트래픽을 다른 프로토콜로 자동으로 변환하여, HTTP 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속가능하게 해준다.

1. HTTP클라 -> 게이트웨이 -> FTP서버
    HTTP로 요청하면 게이트웨이가 FTP로 요청하여 응답 
2. HTTPS클라 -> 게이트웨이 -> HTTP웹서버
    클라이언트 측 보안 가속 게이트웨이
    웹 서버 앞단에서 HTTPS 트래픽을 받아서 복호화하고, 웹서버로 보낼 일반 HTTP요청을 만듦 
    -> 서버에 HTTPS를 단다 = 보통 이걸 의미함
3. HTTP클라 -> 앱서버 -> 프로그램
    각 리소스별로 올바른 프로그램에 연결해주는 형태


### 클라이언트 게이트웨이 vs 서버 게이트웨이
서버 게이트웨이 : 클라이언트와 HTTP 로 통신, 서버와는 외레 프로토콜로 통신
클라이언트 게이트웨이 : 클라이언트와 외래 프로토콜로 통신, 서버와는 HTTP 로 통신

### CGI Common Gateway Interface
최초의 우명한 애플리케이션 게이트웨이
URL에 대한 HTTP요청에 따라 프로그램을 실행하고, 프로그램의 출력을 수집, HTTP응답으로 회신하는데 웹서버가 사용하는 표준화된 인터페이스 집합

게이트 웨이을 통해야 받을 수 있는 요청이 들어오면 헬퍼 애플리케이션을 생성하여 요청을 처리함

동작방식
1. 사용자가 브라우저에서 URL을 요청하거나 폼을 제출
`http://example.com/cgi-bin/script.cgi?name=Alice`

2. 웹 서버(Apache, Nginx 등)는 요청이 CGI 스크립트를 가리킨다는 것을 인식

3. 서버는 CGI 프로그램(보통 실행 가능한 스크립트나 바이너리)을 실행하고, 입력값(쿼리 파라미터, POST 데이터 등)을 프로그램에 전달

4. CGI 프로그램은 처리 결과를 표준 출력(stdout) 으로 반환
5. 서버는 프로그램 출력을 브라우저에 전달

| 구분       | CGI                                | WAS                                       |
|------------|------------------------------------|-------------------------------------------|
| 처리 방식  | 요청마다 새 프로세스 실행          | 멀티스레드 기반, 스레드 풀 재사용         |
| 성능       | 요청 많을수록 비효율적 (부하↑)     | 효율적, 대규모 트래픽 처리 가능           |
| 주요 역할  | 단순 실행 인터페이스               | 애플리케이션 실행 + 관리 (JSP, Servlet 등) |
| 확장성     | 낮음                               | 높음                                      |
| 예시       | Perl, Python CGI 스크립트          | Tomcat, JBoss, WebLogic, WebSphere        |


## 터널
웹터널 -> HTTP를 지원하지 않는 애플리케이션에 대해 HTTP 애플리케이션을 통해 접근하는 방법을 제공함
웹터널을 사용하면 HTTP 커넥션을 통해 HTTP가 아닌 트래픽을 전송할 수 있음 + 다른 프로토콜을 HTTP위에 올릴 수 있음


### 요청
HTTP의 CONNECT 메서드를 통해 연결을 함 -> 터널 게이트웨이가 임의의 목적 서버와 포트에 TCP커넥션을 맺고, 클라와 서버간 데이터를 무조건 전달하기를 요청함

```
CONNECT home.netscape.com:443 HTTP/1.0
User-agent : Mozila/4.0
```
시작줄에 URI를 호스트명이 대신함

### 응답
Connection Established로 연결 확인
Content-Type헤더가 필요없음
커넥션이 메시지 전달 대신 바이트를 그대로 전달하기 때문임

### 전송중
터널을 통해 전달되는 데이터는 게이트웨이에서 볼 수 없음
게이트웨이는 패킷의 순서나 흐름에 대한 어떤 가정도 할 수 없음

### SSL 터널링
SSL과 같은 암호화된 프로토콜은 정보가 암호화되어 낡은 방식 프록시에서는 처리되지 않음
터널을 사용하면 SSL트래픽을 HTTP커넥션으로 전송해서 HTTP만을 허용하는 방화벽을 통과시킴

### SSL 터널링 vs HTTP/HTTPS 게이트웨이
잘 이해 못했습니다..


### 터널인증
-> 통신 프로토콜이 터널을 올바른 용도로 사용하고 있는지 검증할 방법이 없음

## 릴레이
HTTP명세를 완전히 준수하지는 않는 간단한 HTTP 프록시
그냥 전달만 함
Keep-Alive등의 헤더를 올바르게 해석하지 못하면 문제가됨

# 9장 웹로봇
사람과 상호작용 없이 연속된 웹 트랜잭션들을 자동으로 수행하는 소프트웨어
-> 크롤러, 스파이더, 웜, 봇 등

### 크롤러 원리
root 웹 -> 링크를 만나면 크롤링 목록에 추가

### 순환 피하기
어디 방문했는지 표기해야함

### 가상 호스팅
크롤러는 Host헤더를 써야함 -> 헤더기반의 가상 호스팅이 구현되어 있고, 크롤러가 가상 호스팅을 지원하지 않는다면 원하는 정보를 얻을 수 없음

