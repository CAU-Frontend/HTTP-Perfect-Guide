# 7장 캐시

캐시가 주는 혜택

- 불필요한 데이터 전송 줄임 → 네트워크 요금으로 인한 비용 감소
- 네트워크 병목 감소, 대역폭을 늘리지 않고도 빠른 페이지 불러오기
- 원서버에 대한 요청 감소, 서버 부하 감소
- 거리로 인한 지연 감소

## 7.1 불필요한 데이터 전송

캐시를 이용하면, 첫번째 서버 응답은 캐시에 보관. 캐시된 사본이 뒤이은 요청에 대한 응답으로 사용될 수 있음 
→ 원서버가 중복해서 트래픽을 주고받는 낭비 감소

## 7.2 대역폭 병목

많은 네트워크가 원격서버보다 로컬네트워크 클라이언트에 더 넓은 대역폭 제공

클라이언트가 서버에 접근할 때의 속도 = 그 경로에 있는 가장 느린 네트워크의 속도

LAN에 있는 캐시로부터 사본을 가져온다면 성능을 대폭 개선 가능

## 7.3 갑작스런 요청 쇄도 Flash Crowds

캐싱은 트래픽 급증에 대처하기 위해 중요

## 7.4 거리로 인한 지연

대역폭이 문제가 되지 않더라도, 거리가 문제가 될 수 있음. 네트워크 라우터는 제각각 인터넷 트래픽을 지연시킴. 빛의 속도 그 자체가 유의미한 지연을 유발

근처에 캐시를 설치해서 데이터가 전송되는 거리를 단축

## 7.5 적중과 부적중

캐시에 요청 도착 시 사본이 있다면 → cache hit. 없다면 원서버로 → cache miss

- revalidation
    - 원서버 콘텐츠와 캐시의 콘텐츠가 불일치할 수 있음. 신선도 검사 필요
    - 캐시는 원한다면 언제든 사본 재검사가 가능. 하지만 캐시가 많은 데이터를 갖고 있는 경우에 비해 네트워크 대역폭은 부족하기 때문에, 사본이 검사를 할 필요가 있을 정도로 충분히 오래된 경우에만 재검사 진행
    - 재검사 시, 원 서버에 작은 재검사 요청을 보냄
        - 변경되지 않았다면 `304 Not Modified` → 느린 hit
    - HTTP는 캐시된 객체를 재확인하기 위해 몇가지 도구 제공
        - **If-Modified-Since 헤더**
            - 서버에 보내는 GET요청에 추가하면 캐시된 시간 이후에 변경된 경우에만 사본을 보내달라는 의미
            - 해당 헤더를 이용해 재검사 요청 예시
                - hit: 서버 객체가 변경되지 않았으면 304 응답
                - miss: 캐시된 사본과 다르다면, 서버는 콘텐츠 전체와 함께 200 응답
                - 객체 삭제: 서버 객체가 삭제 되었다면 404 응답 → 사본 삭제
- 적중률 hit rate (=캐시적중률, 문서 적중률)
    - 캐시가 요청을 처리하는 비율. 오늘날 적중률 40%면 웹캐시로 괜찮은 편.
- 바이트 hit rate
    - 문서들이 모두 같은 크기인 것은 아니기 때문에 어떤 사람들은 바이트 단위 적중률 측정값을 더 선호.
    - 트래픽이 절감된 정도를 포착함.

→ 둘다 캐시 성능에 대한 유용한 지표.

- 적중과 부적중의 구별
    - 캐시나 원서버나 둘다 응답코드는 200 OK일것임
    - 클라이언트가 알아내는 법은 `Date 헤더`
        - 응답의 Date 헤더를 현재 시간과 비교하여 응답의 생성일이 더 오래됐다면 캐시된것임
        - 응답이 얼마나 오래되었는지 확인하는 `Age 헤더`를 사용할 수도 있음

## 7.6 캐시 토폴로지

- private cache
    - 한명에게만 할당된 캐시. 한명의 사용자가 자주 찾는 페이지를 담음
    - 많은 에너지나 공간 불필요. 작고 저렴
    - 웹브라우저는 개인전용캐시를 내장하고 있음. 보통 자주쓰이는 문서를 개인용컴퓨터의 디스크와 메모리에 캐시해놓고, 사용자가 캐시 사이즈와 설정을 수정할 수 있도록 허용함. (크롬 about:cache를 통해서 확인 가능)
- public cache
    - 공유된 캐시. 사용자 집단에게 자주 쓰이는 페이지를 담은
    - 캐시 프락시 서버, 프락시 캐시라고 불리는 특별한 종류의 공유된 프락시 서버
    - 여러 사용자가 접근하기 때문에 불필요한 트래픽을 줄일 수 있음
    - 같이 공유된 캐시에서 캐시는 자주 찾는 객체를 단 한번만 원서버에서 가자와 모든 요청에 공유된 사본을 제공함으로 트래픽을 줄임
    - 프락시 캐시 계층들
        - 작은 캐시에서 miss → 더 큰 부모 캐시가 걸러 남겨진 트래픽을 처리하도록 하는 계층을 만드는 방식이 합리적인 경우가 많음
- 캐시망, 콘텐츠 라우팅 피어링
    - 단순한 캐시계층 대신 좀더 복잡한 캐시망을 사용할 수도 있음
        - 프락시 캐시들이 복잡한 방법으로 서로 대화. 캐시 커뮤니케이션 결정을 동적으로 내보냄
        - 캐시망 내에서 콘텐츠 라우팅을 위해 설계된 캐시의 예시
            - URL에 근거해, 부모 캐시와 원서버 중 하나를 동적으로 선택
            - URL에 근거해, 특정 부모 캐시를 동적으로 선택
            - 부모 캐시에게 가기 전에, 캐시된 사본을 로컬에서 찾아봄
            - 다른 캐시들이 그들의 캐시된 콘텐츠에 부분적으로 접근할 수 있도록 허용하되, 그들의 캐시를 통한 인터넷 트랜짓(트래픽이 다른 네트워크로 건너가는 것)은 허용하지 않음
        - 서로 다른 조직이 상호이득을 위해 그들의 캐시를 연결하는 것을 피어링(형재캐시)라고 함. HTTP는 형제캐시 지원하지 않음. 따라서 ICP나 HTCP로 HTTP를 확장해서 사용함.

## 7.7 캐시 처리 단계

1. 요청 받기
    1. 캐시는 네트워크 커넥션에서의 활동을 감지하고 들어오는 데이터들을 읽음
    2. 코성능 캐시는 여러개의 들어오는 커넥션들로부터 데이터를 동시에 읽고, 메시지 전체가 도착하기 전에 트랜잭션 처리를 시작
2. 파싱
    1. 요청 메시지를 여러부분으로 파싱하여 헤더 부분을 조작하기 쉬운 자료구조에 담음
        1. 캐싱 소프트웨어가 헤더 필드를 처리하고 조작하기 쉽게 만들어줌
3. 검색
    1. 캐시는 URL을 알아내고 로컬 사본이 있는지 검사. 전문적인 캐시는 알고리즘을 사용해 확인함.
    2. 캐시된 객체는 캐시 적중동안 올바른 서버 헤더가 반환될 수 있음. 캐시에 머무른 시간과 같은 메타데이터를 포함
4. 신선도 검사
    1. HTTP는 캐시가 일정기간 동안 서버의 문서의 사본을 보유할 수 있도록 해줌 → 해당 기간 동안 문서는 신선한 것으로 간주되고 서버와 접촉없이 해당 문서 제공 가능
    2. 신선도 한계를 넘으면 stale. 서버와 재검사 필요.
    3. HTTP의 신선도 검사규칙 매우 복잡
5. 응답 생성
    1. 원서버에서 온 것처럼 보이게 하고 싶기 때문에, 캐시는 캐시된 서버 응답 헤더를 토대로 응답헤더 생성.
    2. 캐시는 클라이언트에 맞게 이 헤더를 조정.
    3. 캐시 신선도 정보 삽입 (Cache-Control, Age, Expires, Via…)
6. 전송
    1. 응답 헤더가 준비되면 캐시는 응답을 클라이언트에게 돌려줌
    2. 프락시 서버들과 마찬가지로 프락시 캐시는 클라이언트와 커넥션을 유지할 필요가 있음.
7. 로깅
    1. 대부분의 캐시는 로그파일과 캐시사용에 대한 통걔 유지.
    2. 트랜잭션 완료 후, 캐시는 통계 캐시 hit와 miss 횟수에 대한 통계 갱신, 요청 종류, URL 등 항목을 추가
    3. 스퀴드 로그 포맷, 넷스케이프 확장공용 로그포맷을 많이 씀

## 7.8 사본을 신선하게 유지하기

캐시된 사본 모두가 서버의 문서와 항상 일치하는 것은 아님. 시간에 따라 변경.

HTTP는 어떤 캐시가 사본을 갖고 있는지 서버가 기억하지 않더라도, 서버와 충분히 일치하도록 유지할 수 있게 해주는 단순한 매커니즘을 갖는다.

HTTP는 이 단순한 매커니즘을 문서 만료와 서버 재검사 라고 부름

- 문서 만료
    - HTTP는 `Cache-Control`과 `Expires` 라는 특별한 헤더를 이용해서 원 서버가 각 문서에 유효기간을 붙일 수 있게 해준다.
    - 캐시 문서가 만료되기전 캐시는 필요하다면 서버와의 접촉 없이 사본을 제공할 수 있음. 일단 캐시된 문서가 만료되면, 캐시는 반드시 서버와 문서에 변경된 것이 있는지 검사해야하며 만약 그렇다하면 신선한 사본을 얻어와야 함.
- 유효기간과 나이
    - 서버는 응답 본문과 함께 `Expires` 나 `Cache-Control: max-age` 응답 헤더를 이용해서 유효기간을 명시
    - max-age 값은 문서의 최대 나이 정의. 최대 나이는 문서가 처음 생성된 이후부터, 제공하기엔 더이상 신선하지 않다고 간주될때까지 경과한 시간의 합법적인 최댓값 (초단위)
    - `Expires` 는 절대 유효기간을 표시. 날짜.
- 서버 재검사
    - 재검사 후 변경되었을때
        - 캐시는 그 문서의 새로운 사본을 가져와 오래된 데이터 대신 저장한뒤 클라이언트에게 보냄
    - 재검사 후 변경되지 않았을때
        - 캐시는 새 만료일을 포함한 새 헤더들만 가져와서 캐시 안의 헤더들을 갱신
    - HTTP 프로토콜은 캐시가 다음 중 하나를 반환하는 적절한 행동을 할 것을 요구
        - 충분히 신선한 캐시된 사본
        - 원 서버와 재검사 되었기 때문에, 충분히 신선하다고 확신할 수 있는 캐시된 사본
        - 에러 메세지( 원 서버가 다운된 경우)
        - 경고 메세지가 부착된 캐시 사본
- 조건부 메서드와 재검사
    - HTTP의 조건부 메서드는 재 검사를 효율적으로 만들어줌
    - HTTP는 캐시가 서버에게 `조건부 GET` 이라는 요청을 보낼 수 있도록 해줌.
        - 서버가 갖고있는 문서가 캐시가 갖고 있는 것과 다른 경우에만 객체 본문을 보내달라고 하는 것
    - HTTP는 다섯가지 조건부 요청 헤더를 정의
        - **If-Modified-Since: 날짜 재검사**
            - 서버에게 리소스가 특정 날짜 이후 변경된 경우에만 요청한 본문을 보내달라고 함
        - **If-None-Match: 엔터티 태그 재검사**
            - If-Modifed-Since검사가 적절히 행해지기 어려운 상황
                - 일정간격으로 다시 쓰여졌지만 실제로는 같은데이터를 포함하고 있을때
                - 최근 변경일시를 정확하게 판별할수 없을때
                - 1초보다 작은간격으로 갱신되는 문서를 제공하는 서버 등
            - 엔터티 태그 재검사는 문서의 엔티티 태그를 새로운 버전으로 표현
            - 엔터티 태그가 변경되었다면, 캐시는 새문서의 사본을 얻기(GET)위해 If-None-Match 조건부 헤더를 사용
                - 태그가 변경되었다면, 서버는 200응답으로 새콘텐츠를 새ETag와 함께 반환
- 약한 검사기와 강한 검사기
    - HTTP/1.1은 비록 콘텐츠가 조금 변경되었더라도 “그 정도이면 같은것” 이라고 서버가 주장할 수 있도록 해주는 약한 검사기 를 지원한다.
    - 강한 검사기 는 콘텐츠가 바뀔때마다 바뀐다.
    - 약한 검사기는 어느 정도 콘텐츠 변경을 허용하지만, 콘텐츠의 중요한 의미가 변경되면 함께 변경

## 7.9 캐시 제어

- HTTP는 문서가 만료되기 전까지 얼마나 오랫동안 캐시될 수 있게 할것인지 서버가 설정 할 수있는 여러가지 방법을 정의함
- no-store와 no-cache 응답 헤더는 캐시가 검증되지 않은 캐시된 객채로 응답하는것을 막음
    - **no-store:** 이 표시가 표시된 응답은 캐시가 그 응답의 사본을 만드는것을 금지함. 따라서 캐시서버는 클라이언트에게 응답을 전달하고 나면 객체를 삭제함
    - **no-cache**: 이 표시가 표시된 응답은 사실 로컬 캐시 저장소에 저장될 수 있음. but 먼저 서버와 재검사를 하지 않고서는 캐시에서 클라이언트로 제공될 수 없음
- Max-Age 응답 헤더
    - Cache-Control: max-age 헤더는 신선하다고 간주되었던 문서가 서버로부터 온 이후로 흐른 시간이고, 초로 나타냄
    - s-maxage헤더는 max-age처럼 행동하지만 공유된(공용) 캐시에서만 적용
- Expires 응답 헤더
    - 더 이상 사용하지 않기를 권하는 Expires 헤더는 초 단위의 시간 대신 실제 만료 날짜를 명시
        - why? 많은 서버가 동기화 되어있지 않거나 부정확한 시간을 갖고있기 때문
- Must-Revalidate 응답 헤더
    - 캐시가 이 객체의 신선하지 않은 사본을 원 서버와의 최초의 재검사 없이는 제공해서는 안됨을 의미
    - 만약 해당 캐시가 신선도 검사를 시도했을 떄 원 서버가 사용 할 수 없는 상태라면 `504 Timeout erorr` 를 반환해야함
- 휴리스틱 만료
    - 만약 응답에 위 헤더들 어느것도 포함하지 않고 있다면, 캐시는 경험적인 방법으로 최대 나이를 계산할 것
    - 계산 결과 얻은 최대 나이 값이 24시간보다 크다면 Heuristic Expiration 경고 헤더가 응답 헤더에 추가 되어야함
    - 만약 캐시된 문서가 마지막으로 변경된것이 상당히 예전 → 갑자기 바뀔 가능성은 별로 크지 않을 것이므로, 캐시에 더 오래 보관하고 있어도 안전
    만약 캐시된 문서가 최근에 변경 → 아마 자주 변경될 것이고, 따라서 우리는 그것을 서버와 재검사하기 전까지 짧은 기간동안만 캐시해야 함
- 클라이언트 신선도 제약
    - 클라이언트는 Cache-Control 요청 헤더를 사용하면 만료 제약을 엄격하게 하거나 느슨하게 할 수 있음

# 8장 통합점: 게이트웨이, 터널, 릴레이

## 8.1 게이트웨이

웹이 더 복잡한 리소스를 올려야 할 필요가 생기면서 한개의 애플리케이션으로만 처리할 수 없다는 것은 분명해짐

→ 인터프리터 같이 리소스를 받기위한 경로를 안내하는 역할을 하는 게이트웨이를 고안

- **게이트웨이는 리소스와 애플리케이션을 연결하는 역할**
    - 애플리케이션은 게이트웨이에게 요청을 처리해달라고 할 수 있고, 게이트 웨이는 응답을 할 수 도 있음
    - 동적인 콘텐츠를 생성하거나 DB에 질의를 보낼 수 있음
    - HTTP 트래픽을 다른 프로토콜로 자동으로 변환하여, HTTP 클라이언트가 다른 프로토콜을 알 필요 없이 서버에 접속할 수 있게 하기도 함
    - 애플리케이션 서버 게이트웨이 API를 통해서 HTTP 클라이언트를 서버 측 애플리케이션 프로그램에 연결
    - 웹 게이트웨이는 한쪽에서는 HTTP로 통신하고 , 다른 한쪽에서는 HTTP가 아닌 다른 프로토콜로 통신
        - 게이트웨이는 클라이언트 측 프로토콜과 서버 측 프로토콜을 빗금(/)으로 구분
            - e.g. HTTP 클라이언트와 NNTP 뉴스 서버 사이에 있으면 `HTTP/NNTP` 게이트웨이

## 8.2 프로토콜 게이트웨이

프락시에 트래픽을 바로 보내는 것과 같이 게이트웨이에도 HTTP 트래픽을 바로 보낼수 있음

보통 브라우저에 명시적으로 게이트웨이를 설정하여 자연스럽게 트래픽이 게이트웨이를 거쳐 가게 하거나, 게이트웨이를 대리서버(리버스 프락시)로 설정할 수 있음

- 예시
    - **HTTP/*: 서버 측 웹 게이트웨이**
        - 서버 측 웹 게이트웨이는 클라이언트로부터 HTTP 요청이 원 서버 영역으로 들어오는 시점에 클라이언트 측의 HTTP 요청을 외래 프로토콜로 전환
        - 응답을 할때도 외래 프로토콜을 클라이언트 측에 HTTP 로 변환 후 보냄
    - **HTTP/HTTPS: 서버 측 보안 게이트웨이**
        - 기업 내부의 모든 웹 요청을 암호함으로써 개인 정보 보호와 보안을 제공하는데 게이트웨이를 사용 가능
        - 클라이언트는 일반 HTTP를 사용하여 웹을 탐색할 수 있지만, 게이트웨이는 자동으로 사용자의 모든 세션을 암호화함
    - **HTTPS/HTTP : 클라이언트 측 보안 가속 게이트웨이**
        - 웹 서버의 앞단에 위치하고, 보이지 않는 인터셉트 게이트웨이나 리버스 프락시 역할
        - 보안 HTTPS 트래픽을 받아서 복호화하고, 웹 서버로 보낼 일반 HTTP 요청을 만듦
        - 원서버의 부하를 줄여주지만, 게이트웨이와 원서버 간의 암호화하지 않는 트래픽을 전송하기 때문에, 게이트웨이와 원서버 간에 있는 네트워크가 안전한지 확인을 확실히 하고 사용해야함

## 8.3 리소스 게이트웨이

게이트웨이의 가장 일반적인 형태인 애플리케이션 서버는 목적지 서버와 게이트웨이를 한 개의 서버로 결합

애플리케이션 서버는 게이트웨이의 애플리케이션 프로그래밍 인터페이스(API)를 통해서 요청을 서버에서 동작하고 있는 애플리케이션에 전달

- **CGI**(Common Gateway Interface)
    - 특정 URI에 대한 HTTP요청에 따라 프로그램을 실행하고, 프로그램의 출력을 수집하고, HTTP 응답으로 회신하는데 웹 서버가 사용하는 표준화된 인터페이스 집합

게이트웨이를 통해야 받을 수 있는 리소스 요청이 들어오면, 서버는 헬퍼 애플리케이션을 생성하여 요청을 처리 → 요청 처리 후, 클라이언트로 전달할 응답이나 응답 데이터를 서버에 반환

- 공용 게이트웨이 인터페이스
    - CGI 애플리케이션이 서버와 분리되면서 펄(Perl), TcL, C, 다양한 셸 언어를 포함하여 수 많은 언어로 구현할 수 있게 됨
    - 인터페이스는 문제가 많은 확장으로부터 서버를 보호. 문제가 있는 확장이 서버 자체에 들어가면, 에러를 발생시키고 서버를 뻗게 할 것이기 때문

## 8.4 애플리케이션 인터페이스와 웹 서비스

애플리케이션이 상호 운용응 하다 보면 HTTP 헤더로는 표현하기 힘든 복잡한 정보를 교환해야 할 수도 있음

웹 서비스는 애플리케이션이 정보를 공유하는 데 사용하는 새로운 메커니즘(표준과 프로토콜 집합)을 의미. 웹 서비스는 HTTP같은 표준 웹 기술 위에서 개발

## 8.5 터널

웹 터널은 HTTP 프로토콜을 지원하지 않는 애플리케이션에 HTTP 애플리케이션을 사용해 접근하는 방법을 제공

- **CONNECT로 HTTP 터널 커넥션 맺기**
    - `HTTP CONNECT` 메서드
        - 터널 게이트웨이가 서버에 TCP커넥션을 맺고 클라이언트와 서버 간에 오는 데이터를 무조건 전달하기로 요청하는 메서드
        - 터널 커넥션 과정
            1. 클라이언트는 게이트웨이에 터널을 연결하려고 CONNECT 요청 전송
            2. TCP 커넥션이 생성 완료되면, 게이트웨이는 클라이언트에 HTTP 200 Connection Established 응답을 전송
            3. 이 시점에 터널이 연결
            4. 이 시점부터 커넥션이 끊길 때까지 모든 데이터가 일방향으로 전달
- **데이터 터널링, 시간, 커넥션 관리**
    - 클라이언트는 성능을 높이기 위해 CONNECT 요청을 보낸 다음, 응답을 받기 전에 터널 데이터를 전송할 수 있음
- **SSL 터널링**
    - 웹터널은 원래 방화벽을 통해서 암호화된 SSL 트래픽을 전달하려고 개발됨
    - SSL과 같이 암호화된 프로토콜은 정보가 암호화되어서 낡은방식의 프락시에서는 처릭 안됨 → 터널을 사용하면 SSL 트래픽을 HTTP 커넥션으로 전송하여 80 포트의 HTTP 만을 허용하는 방화벽을 통과시킬 수 있음
    - 터널링 기능은 HTTP 메시지에 암호화된 날 데이터를 담고 일반 HTTP 채널을 통해 데이터를 전송
- **SSL 터널링 vs HTTP/HTTPS 게이트웨이**
    - SSL 터널링을 사용하면, 프락시에 SSL을 구현할 필요가 없음
    - SSL 세션은 클라이언트가 생성한 요청과 목적지(보안이 적용된) 웹 서버 간에 생성
    - 프락시 서버는 트랜잭션의 보안에는 관여하지 않고 암호화된 데이터를 그대로 터널링할 뿐이다

## 8.6 릴레이

HTTP 릴레이는 HTTP명세를 준수하지 않는 간단한 HTTP프락시

- 릴레이 문제
    1. 웹 클라이언트는 Connection: Keep-Alive 헤더를 보내서 릴레이와 Keep-Alive 상태를 유지하기를 원한다
    2. 릴레이는 이해하지 못해 그대로 서버에 전달한다
    3. 서버는 릴레이가 릴레이와의 Keep-Alive 상태를 유지하기를 원한다고 생각한다
    4. 릴레이는 받은 Keep-Alive 를 그대로 클라이언트에 전달한다
    5. 클라이언트는 릴레이와 Keep-Alive 를 유지한다고 생각한다
    6. 클라이언트는 릴레이에게 다음 요청을 보낸다
    7. 릴레이는 서버와의 커넥션을 계속 유지하고 있으므로 커넥션이 닫히기만을 기다린다
    8. 브라우저는 계속 돌고 있지만, 아무런 작업도 진행되지 않는다
