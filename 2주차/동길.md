# HTTP 아키텍처
## 5장 웹서버
웹서버는 www의 일꾼이다.

### 다목적 소프트웨어 웹 서버
웹 서버 소프트웨어는 거의 모든 컴퓨터와 운영체제에서 동작함

### 임베디드 웹 서버
프린터나 가전 제품 등에 내장될 목적으로 만들어진 작은 웹서버

### 웹서버가 하는 일
1. 커넥션을 맺는다.
2. 요청을 받는다.
3. 요청을 처리한다.
4. 리소스에 접근한다.
5. 응답을 만든다.
6. 트랜잭션을 로그로 남긴다.


#### 1. 커넥션수락
이미 열려있는 지속 커넥션이있다면, 요청을 보내기 전에 그 커넥션을 사용한다.
아닌 경우 커넥션을 새로 열어야한다.

서버는 어떤 커넥션이든 마음대로 거절하거나 즉시 닫을 수 있다.

ident 포로토콜로 클라이언트 사용자를 알아낼 수 있다. 보통 조직 내부에서는 사용하지만, 공용 인터넷에서는 사용하지 않는다.
1. ident는 안전하지 않고, 조작이 쉽다.
2. ident프로토콜은 http 트랜잭션을 유의미하게 지연시킨다.
3. 방화벽이 ident 트래픽이 들어오는 것을 막는 경우가 많다.

#### 2. 요청 메시지 수신

웹서버는 요청 메시지를 파싱한다.
파싱을 해서 헤더와 메서드, 식별자, 버전 정보들을 찾아서 헤더 끝을 의미하는 CRLF로 끝나는 빈줄을 찾는다.
본문이 있다면 읽어들인다.

웹서버는 네트워크에서 바로 읽는게 아니라, 메모리에 임시로 저장해둘 필요가 있다.
-> 서버 요청 메시지를 쉽게 다룰 수 있도록 내부 자료구조에 저장한다.


### 커넥션 입/출력 처리 아키텍처

#### 1. 단일 스레드 웹서버

한번에 하나씩 요청을 처리한다.
트랜잭션이 완료되어야 다음 커넥션이 처리된다.
이 아키텍쳐는 구현하기 간단하지만, 처리 도중에 다른 모든 커넥션이 무시된다.
-> 심각한 성능 문제를 만들어 낸다.

#### 멀티 프로세스와 멀티스레드 웹서버

멀티 프로세스와 스레드 웹서버는 여러개의 프로세스와 스레드를 할당한다.
수만개의 동시 커넥션을 처리할 때 그로 인해 만들어진 수 많은 프로세스나 스레드는 너무 많은 메모리나 시스템 리소스를 소비한다.
이 때문에 웹서버가 보통 스레드/프로세스의 최대 개수에 제한을 건다.
이를 개선하기 위한 방안

1. 다중 I/O 서버
모든 커넥션은 동시에 그 활동을 감시당한다.
그러다가 상태가 바뀌면, 그 커넥션에 대해 작은 양의 처리가 수행된다.
커넥션은 다음번 상태 변경을 위해 열린 커넥션 목록으로 돌아간다.

```
 I/O의 병목
- 서버가 클라이언트 요청을 처리할 때 가장 시간이 오래 걸리는 부분은 I/O (입출력) 입니다.
- 디스크 읽기/쓰기, 네트워크 송수신, DB 접근 같은 작업들이 대표적이죠.
- CPU 연산은 빠른데, I/O는 상대적으로 느리기 때문에 서버 아키텍처 설계는 어떻게 I/O 대기를 효율적으로 처리하느냐가 핵심입니다.

다중 I/O 서버 아키텍처 유형

(1) 스레드 기반 (Thread-per-Request)
- 요청마다 스레드를 생성해 I/O를 처리.
- 구현이 간단하지만, 동시 연결 수가 많아지면 스레드 수 폭발 → 컨텍스트 스위칭 비용 증가.
- 전통적인 아파치 HTTP 서버 초기 버전에서 사용.

⸻

(2) 이벤트 루프 기반 (Non-blocking I/O, Reactor 패턴)
- 단일(또는 소수) 스레드가 이벤트 루프를 돌면서 여러 I/O 요청을 비동기로 관리.
- 각 I/O 작업 완료 시 콜백/이벤트로 처리.
- Node.js, Nginx가 대표적.
- 장점: 메모리 효율적이고, 동시 연결에 매우 강함.
- 단점: CPU 바운드 작업에 약함(→ 별도 워커/스레드풀 필요).

(3) I/O 멀티플렉싱 (select/poll/epoll/kqueue)
- 단일 스레드가 여러 소켓을 동시에 감시.
- 운영체제가 제공하는 멀티플렉싱 시스템콜(select, poll, epoll, kqueue)을 활용.
- 이벤트 루프 기반 아키텍처의 핵심 기술.
- Linux의 epoll, BSD의 kqueue가 고성능 서버에 많이 쓰임.

```


2. 다중 멀티스레드 웹서버
몇몇 시스템은 CPU 여러 개의 이점을 살리기위해 멀티스레딩과 다중화(multiplexing)을 결합한다.
여러개의 스레드는 열려 있는 커넥션을 감시하고, 각 커넥션에 대해 조금씩 작업을 수행한다.

다중화(멀티플렉싱)?
하나의 실행흐름이 동시에 여러개의 IO채널을 감시하고 처리하는 기술



구조 유형
```
(1) 요청당 스레드 (Thread-per-request)
- 각 요청마다 새로운 스레드 생성.
- 구현은 간단하지만, 요청이 많아질수록 스레드 수 폭증 → 메모리, 컨텍스트 스위칭 비용 증가.
- 예전 Apache HTTP Server (prefork/threaded 모드) 가 이 방식을 사용.


(2) 스레드 풀(Thread Pool) 방식
- 미리 여러 스레드를 만들어두고 요청을 큐에 넣어 처리.
- 요청이 오면 큐에 쌓이고, 여유 있는 스레드가 꺼내서 처리.
- 불필요한 스레드 생성을 피하고 안정적.
- 대표 예: Java의 Tomcat, Jetty / Python Gunicorn (gthread 모드) / IIS


(3) 멀티프로세스 + 멀티스레드 하이브리드
- 여러 프로세스(멀티코어 활용) + 각 프로세스 안에서 멀티스레드.
- 대규모 트래픽 처리에 강함.
- 예: Oracle WebLogic, IBM WebSphere 같은 엔터프라이즈 서버.
```

| 구분 | 다중 I/O 서버 아키텍처 | 다중 멀티스레드 웹서버 |
|------|----------------------|-----------------------|
| **핵심 모델** | 이벤트 루프 + 멀티플렉싱(`epoll`, `kqueue`) | 요청당 스레드 or 스레드 풀 |
| **동시성 처리** | 하나(또는 소수) 스레드로 수천~수만 연결 처리 | 스레드 수만큼 연결 처리 |
| **리소스 효율** | 메모리/CPU 효율적, 스레드 적음 | 스레드 많아질수록 메모리/CPU 오버헤드 증가 |
| **컨텍스트 스위칭** | 거의 없음 | 많음 (스레드 전환 비용 존재) |
| **CPU 활용** | CPU 바운드 작업에 취약 → 별도 워커 필요 | CPU 멀티코어 활용에 강함 |
| **코드 복잡성** | 비동기/콜백 코드로 복잡 | 구조 단순 (동기 처리 직관적) |
| **장점** | - 수십만 동시 연결 처리 가능 <br>- 고성능, C10K 문제 해결 | - 코드 구조 단순 <br>- CPU 연산 많은 작업에 적합 |
| **단점** | - CPU 집중 작업에 약함 <br>- 비동기 코드 복잡 | - 스레드 폭증 시 자원 소모 ↑ <br>- 수만 연결 처리 비효율적 |
| **대표 사례** | Nginx, Node.js, Redis, Netty | Apache, Tomcat, Jetty, IIS |


#### 3. 요청 처리
POST등의 몇몇 메서드는 엔터티 본문이 있을 것을 요구한다.
OPTIONS등의 메서드는 요청이 있는 것은 허용하되, 요구하지는 않는다.
GET은 본문이 있는 것을 금지하기도 한다.


#### 4. 리소스 매핑과 접근

웹서버는 리소스 서버다.
미리 만들어진 컨텐츠를 제공하며, 동적 컨텐츠를 만들어서 보내기도 한다.

1. docroot

리소스 매핑의 원천이 되는 경로 설정

2. 가상 호스팅된 docrot
ip 주소나 호스트 등으로 구분해서 docroot를 분기하기도 한다.

3. 사용자 홈 디렉터리 docroots
사용자별로 홈디렉터리를 설정하게 할 수 있다.



#### 5. 응답만들기

리소스 식별후. 메서드 동작을 수행한 뒤에 응답 메시지를 반환함
이는 상태코드. 응답 헤더, 응답 본문을 포함함

##### 응답 엔터티
응답 본문을 메시지와 함께 돌려보냄
이는 보통 Content-Type, Content-Length, 실제 응답 본문의 내용을 포함함

MIME 타입 결정
서버는 MIME 타입을 결정해야하하는 책임이 있음
1. mime.types
웹서버는 MIME 타입을 나타내기 위해 파일 이름의 확장자를 사용할 수 있음
웹서버는 각 리소스의 MIME타입 계산을 위하 확장자별 MIME 타입이 담긴 파일을 탐색함


2. 매직 타이핑
MIME타입을 알아내기 위해서 파일 내용을 검사해서 알려진 패턴에 대한 테이블에 해당하는 패턴이 있는지 찾아볼 수있음
확장자 없이 이름이 지어진 경우에 편리함

3. 유형 명시
특정 파일이나 디렉터리 내 파일이 파일 확장자나 내용이 상관없이 어떤 MIME타입을 갖도록 서버에 설정가능함

4. 유형 협상
웹서버는 한 리소스가 여러 종류의 문서 형식에 속하도록 설정이 가능함

리다이렉션

리소스가 이동된 경우, 브라우저가 다른 곳으로 가도록 리다이렉트 시킬 수 있음

1. 영구히 리소스가 옮겨진 경우
-> 301 Moved Permanently

2. 임시로 리소스가 옮겨진 경우
-> 임시적이기 때문에 303 See Other나 307 Temporary Redirect 처리함

3. URL 증가
서버는 종종 context를 포함시키기 위해 재작성된 URL로 리다이렉트시킴
요청 도착시 URL을 생성하고, 이 URL로 리다이렉트 시킴
303, 307 사용

4. 부하 균형
과부화된 서버가 요청을 받으면 덜 부하된 서버로 이전시킴

5. 디렉터리 이름 정규화
/를 빼먹은 경우, 대부분은 /가 없어도 동작되도록 리다이렉트

#### 6. 응답보내기

서버는 여러 커넥션을 가지고 있고 각각의 커넥션은 상태가 모두 다를 수 있음
서버는 이를 추적하면서, 지속적인 커넥션은 특별히 주의하여 다룰 필요가 있음

지속적인 커넥션이라면 Content Length 헤더를 바르게 계산하기 위해 특별한 주의를 필요로 하는 경우나, 클라가 응답이 언제 끝나는지 알 수 없는 경우에 열린상태 유지
비지속인경우, 모든 메시지 전송시 커넥션 닫기

## 6장 프록시

프록시는 중개자다.
클라와 서버 중간에서 HTTP메시지를 정리하는 중개인 역할을 함

### 왜씀?
실용적이고, 유용한 것이라면 뭐든함
보안을 개선하고, 성능을 높여주며, 비용을 절약함
모든 HTTP 트래픽을 들여다보고 건드릴 수 있어서 부가적 가치를 주는 여러 유용한 웹 서비스를 구현하기 위해 트래픽을 감시하고 수정할 수 있다.



### 웹 중개자

프록시가 없으면 클라는 HTTP 서버와 직접 이야기함
프록시가 있다면, 클라는 서버와 대화해주는 프록시와 이야기함

프록시는 웹서버이기도 하고, 클라이기도함
프록시는 반드시 웹서버처럼 요청과 커넥션을 적절히 다루고 응답을 돌려줘야함
동시에, 요청을 보내고 받는 올바른 HTTP클라이언트로 동작해야함


### 개인 프록시와 공유 프록시

공용 프록시
대부분 프록시는 공용이며, 공유된 프록시임
중앙 집중형 프록시를 관리하는게 더 비용 효율이 높고 쉬움


개인 프록시
개인 전용 프록시는 흔하지 않지만 꾸준히 사용됨

### 프록시 vs 게이트웨이
프록시 -> 같은 프로토콜
게이트웨이 -> 다른 프로토콜

게이트 웨이는 프로토콜이 달라도 동작해야함
-> 실질적으로는 모호함
1. 브라우저와 서버가 다른 HTTP버전을 쓰는 경우, 프록시는 약간의 프로토콜 변환을 하기도함
2. 상용 프록시 서버는 SSL, SOCKS 방화벽, FTP 접근을 지원하기 위해 게이트웨이 기능을 구현함


### 프록시 종류

1.  웹 캐시
프록시 캐시는 인기 문서의 로컬 사본을 관리하고, 해당 문서에 대한 요청이 오면 빠르게 제공하여, 느리고 비싼 인터넷 커뮤니케이션을 줄임

2. 대리 프록시 (Surrogate)
웹서버인 것처럼 동작함
공용 콘텐츠에 대한 느린 웹서버 성능을 개선하기 위해 사용될 수 있음
-> 서버 가속기라고 부름

3. 콘텐츠 라우터
인터넷 트래픽 조건과 콘텐츠 종류에 따라 요청을 특정 웹서버로 유도하는 콘텐츠 라우터로 동작


### 프록시 서버 배치

1. 출구 프록시
로컬과 큰 인터넷 사이 트래픽 제어를 위해 프록시를 로컬 출구에 넣을 수 있음

2. 접근 프록시
고객으로부터의 모든 요청을 종합처리하기 위해 ISP 접근 지점에 위치하기도함
ISP는 다운로드 속도개선, 인터넷 대역폭 비용을 줄이기 위해 캐시 프록시를 사용해 많이 찾는 문서들의 사본을 저장함

3. 대리 프록시
네트워크의 엣지 웹서버들이 바로 앞에 위치하여 웹 서버로 향하는 모든 요청을 처리하고,
필요할때만 웹서버에게 자원을 요청할 수 있음
보안기능이나, 서버 앞단에 두어서 성능을 개선

### 프록시 계층

여러개의 프록시 연쇄를 통해 소통가능

### 프록시가 트래픽을 처리하는 방식

1. 클라이언트 수정

브라우저는 수동/자동으로 프록시 설정을 지원함
이게 설정되면, HTTP요청을 의도적으로 원서버가 아닌 프록시로 보냄

2. 네트워크 수정
네트워크 인프라를 가로채서 웹 트래픽을 프록시로 가도록 조정하는 기법이 있음
HTTP 트래픽을 지켜보고 가로채서, 클라이언트 모르게 트래픽을 프록시로 보내는 스위칭 장치와 라우팅 장치를 필요로함

3. DNS 이름 공간 수정
웹서버 앞의 대리 프록시는
웹서버 이름과 IP주소를 자신이 직접 사용함
모든 요청은 서버 대신 대리 프록시로 감

4. 웹 서버 수정
redirection을 클라이언트에게 돌려줘서 클라 요청을 프록시로 리다이렉트 시킴

### 클라이언트 프록시 설정방법
1. 수동 설정
2. 브라우저 기본 설정: 브라우저 벤더나 배포자는 브라우저를 소비자에게 전달 하기전에 프록시를 미리 설정할 수 있다.
3. 프록시 자동 설정(Proxy Auto Configuration, PAC) : JS 프록시 자동 설정 파일에 대한 URI를 제공할 수 있음. 클라이언트는 언제 프록시를 써야하는지, 어떤 서버를 써야하는지 판단하기 위해 JS를 가져와서 실행함
4. 대부분 브라우저는 자동 설정 파일을 다운 받을 수 있는 설정 서버를 자동으로 찾아주는 WPAD를 제공함

### 프록시 요청의 특징

1. 프록시 URI와 서버 URI
둘의 문법과 메시지는 같지만, 예외가 있다.
프록시 통신에서는 완전한 URI를 사용해야한다. 

2. 가상호스팅에서 일어나는 문제
가상으로 호스팅되는 웹서버는 호스트와 포트에 대한 정보가 있는 Host헤더를 요구한다.

+) 가상 호스팅이란?
하나의 서버에서 여러개의 웹사이트를 동시에 운영할 수 있도록 하는 기술
Apache나 Nginx에서 많이 사용됨

방식
1. 이름방식
2. IP 기반
3. 포트기반

3. 인터셉트 프록시의 부분 URI를 사용함
-> 네트워크 영역에서 가로채는 것이기에 부분 URI를 사용

3. 프록시는 프록시 요청과 서버 요청을 모두 다룰 수 있음

명시적 요청은 완전한 URI
아니면 부분 URI
웹서버 요청은 가상 Host 헤더를 사용해야함

### 메시지 추적

#### Via 헤더
메시지가 지나는 각 중간노드의 정보를 나열함
노드를 지날대마다 중간 노드는 Via목록의 끝에 반드시 추가되어야함

Server헤더
프록시는 Server헤더를 수정해서는 안된다.


#### OPTIONS
어떤 기능을 지원하는지 알아보기
Options메서드는 서버아 웹서버의 특정 리소스가 어떤 기능을 지원하는지 알아볼 수 있게 해준다.

1. OPTIONS * HTTP/1.1
-> 서버 전체 능력에 대해 묻는 것
2. OPTIONS 특정리소스 URI HTTP/1.1
지정된 리소스에 대해 가능한 선택적 기능을 서술하는 헤더 필드를 포함한 200OK를 반환

Allow 헤더
1. 요청 URI에 의해 식별되는 자원에 지원되는 메서드들
2. 서버가 지원하는 모든 메서드를 열거



