# 4장 커넥션 관린

- http는 어떻게 TCP 커넥션을 사용하는가
- TCP 커넥션의 지연, 병목, 막힘
- 병렬커넥션, keep-alive 커넥션, 커넥션 파이프라인을 활용한 http 최적화
- 커넥션 관리를 위해 따라야할 규칙들

## 4.1 TCP 커넥션

전세계 모든 HTTP 통신은 패킷 교환 네트워크 프로토콜들의 계층화된 집합인 TCP/IP를 통해 이뤄진다.

일단 커넥션이 맺어지면 클라이언트와 서버 간에 주고받는 메세지들은 손실 혹은 손상되거나 순서가 바뀌지 않고 안전하게 전달된다.

- IP 주소와 포트번호를 가져와 → 웹서버가 TCP 커넥션을 생성하고 → 브라우저가 서버에 요청 메세지 전달 → 서버의 응답 메세지 읽고 → 커넥션 종료

- TCP는 신뢰할 만한 통신 방식을 제공한다.
- TCP는 IP패킷(혹은 IP 데이터그램)이라는 작은 조각을 통해 데이터를 전송한다.
    - 프로토콜 스택: … → IP → TCP → (TLS or SSL: http에 보안기능 추가된 암호화 계층) → HTTP
    - HTTP가 TCP 커넥션을 통해서 메시지 데이터의 내용을 순서대로 보내고, TCP는 **세그먼트** 단위로 데이터 스트림을 나눠, **세그먼트를 IP패킷**에 담아 데이터를 전달한다.
    - 각 TCP 세그먼트는 하나의 IP주소에서 다른 IP주소로 IP패킷에 담겨 전달된다.
- IP패킷 구성: [IP 헤더][TCP 헤더][데이터]
    - 헤더: 발신지 목적지 IP 주소, 크기, 기타 플래그
    - TCP 세그먼트
        - 헤더: TCP 포트 번호, 제어플래그, 순서 및 무결성 검사를 위한 숫자값

- TCP 커넥션은 **<발신지 IP주소, 발신지 포트, 수신지 IP주소, 수신자 포트>** 네 가지 값으로 식별한다.
    - 네가지 커넥션 구성요소를 모두 똑같이 가리키고 있는 커넥션은 있을 수 없다.

## 4.2 TCP의 성능에 대한 고려

HTTP 트랜잭션의 성능은 그 아래 계층인 TCP 성능에 영향을 받는다.

- HTTP 트랜잭션 지연 원인
    1. 클라이언트가 URI에서 웹서버의 IP주소와 포트번호를 알아내는 시간. 캐싱된 것이 없으면 DNS를 통해 변환하는데 수십초의 시간
    2. 클라이언트가 TCP 커넥션 요청을 서버에 보내고 서버가 응답을 회신하기를 기다리는 시간. 보통 1~2초지만 수백개의 트랜잭션이 만들어지면 크게 증가
    3. 커넥션이 맺어지면 HTTP 요청을 새로 생성된 TCP 파이프를 통해 전송. 요청 메시지가 인터넷을 통해 전달되고 서버에 의해 처리되는 시간
    4. 웹서버가 HTTP 응답을 보내는 시간

- TCP 커넥션의 핸드셰이크 지연
    - 클라이언트가 새로운 TCP 커넥션 생성을 위해 SYN 플래그를 가진 TCP 패킷을 보냄
    - 서버가 그 커넥션을 받으면 SYN과 ACK 플래그를 포함한 TCP패킷을 보냄
    - 마지막으로 클라이언트가 커넥션이 잘 맺어짐을 알리기 위해 ACK 신호를 보냄. 이때 데이터도 함께 보낼 수 있음
    
    ⇒ 데이터 크기가 작은 트랜잭션은 이 핸드셰이크에서 50%이상의 시간을 씀
    
- 확인응답 지연
    - 각 TCP 세그먼트는 순번과 데이터 무셜성 체크섬을 가짐. 수신자는 세그먼트를 온전히 받으면 ACK 패킷을 송신자에게 반환
    - 만약 송신자가 timeout 전에 확인응답을 받지 못하면 패킷이 파기되었거나 오류가 있는 것으로 판단하고 데이터를 재전송함
    - 확인응답(ACK)는 크기가 작기때문에 같은 방향으로 송출되는 데이터패킷에 편승해서 전송됨. 편승되는 경우를 늘리려고 **‘확인응답 지연’ 알고리즘**을 통해 특정 시간동안 ACK를 버퍼에 저장해두고 송출 데이터 패킷이랑 같이 전송되려고…
    - 하지만 HTTP 동작 방식에서는 해당 방향으로 송출된 요청 패킷이 많지않기 때문에 확인 응답이 편승할 기회가 많지 않음. → so 확인응답 지연 알고리즘으로 인한 지연이 자주 발생
- TCP slow start
    - 갑작스러운 부하와 혼잡을 방지하기 위해 커넥션 초반에는 커넥션의 최대속도를 제한하고 데이터가 성공적으로 전송됨에 따라 속도 제한을 높여나감
    - TCP가 한번에 전송할 수 있는 패킷 수를 제한. 확인응답을 받으면 전송가능한 패킷수를 늘려나감 → ‘혼잡 윈도를 연다’
- 네이글 알고리즘과 TCP_NODELAY
    - 네이글 알고리즘
        - 패킷을 전송하기 전에 많은 양의 TCP 데이터를 한개의 덩어리로 합친다.
        - 세그먼트가 최대크기가 되지 않으면 전송을 하지 않는다. 다만 다른 모든 패킷이 확인 응답을 받았을 경우에는 최대 크기보다 작은 패킷의 전송을 허락한다.
        
        → 여러 문제점이 있음. 추가적인 데이터를 기다리느라 지연,,
        
    - HTTP 스택에 TCP_NODELAY파라미터 값을 설정해 네이글 알고리즘을 비활성화 하기도.. 해당 설정을 했다면, 작은 크기의 패킷이 너무 많이 생기지 않도록 큰 크기의 데이터 덩어리를 만들어야함
- TIME_WAIT의 누적과 포트 고갈
    - TCP 커넥션을 끊으면, 종단에서는 커넥션의 IP주소와 포트번호를 메모리에 기록해둠. 이는 새로운 TCP 커넥션이 일정 시간 동안에는 생성되지 않기 위한 것. (이전 커넥션의 패킷이 새로운 커넥션으로 가는 것을 막음)
    - 2MSL : 세그먼트의 최대 생명주기에 두배, time wait
    - 보통의 상황에서는 문제가 되지 않음. but 성능시험을 하는 상황에서는 클라이언트가 접속할 수 있는 IP주소의 개수를 제한하고, 부하를 발생시킬 컴퓨터의 수가 적기 때문에…  → so 성능 테스트를 위해 커넥션을 계속 다시 만들어야 하는 상황에서는 TIME_WAIT 포트 고갈로 인해 지연이 생길 수 있음

## 4.3 HTTP 커넥션 관리

HTTP 메시지는 클라이언트에서 서버까지 중개서버들을 거치면서 전달된다.

만약 어떤 헤더가 특정 홈에서만 전달되어야 한다면 HTTP Connection 헤더 필드를 사용한다.

- Connection 헤더에는 다음 세가지 종류의 토큰이 전달될 수 있다.
    - HTTP 헤더 필드 명: 이 커넥션에만 해당되는 헤더 목록
    - 임시적인 토큰 값: 커넥션에 대한 비표준 옵션
    - close 값: 커넥션이 완료되면 종료되어야 함을 의미.

HTTP 커넥션의 성능을 향상 시킬수 있는 기술 3가지

## 4.4 병렬 커넥션

클라이언트는 동시에 HTTP 커넥션을 여러개 맺음으로써 여러개의 HTTP 트랜잭션을 병렬로 처리할 수 있게 한다.

- 병렬 커넥션은 페이지를 더 빠르게 내려받는다
    - 각 커넥션의 지연시간을 겹치게 하면 총 지연시간을 줄일 수 있고, 클라이언트의 인터넷 대역폭을 한 커넥션이 다 써버리는 것이 아니라면 나머지 객체를 내려받는데에 남은 대역폭을 사용할 수 있다.
- 병렬 커넥션이 항상 더 빠르지는 않다
    - 클라이언트의 네트워크 대역폭이 좁을 때, 성능상의 장점은 거의 없어진다.
    - 또한 다수의 커넥션은 메모리를 많이 소모하고 자체적인 성능문제를 발생시킨다. → 서버가 여러 커넥션을 떠안게되므로…
    - 브라우저는 실제로 병렬 커넥션을 사용하지만 적은 수의 병렬 커넥션만을 허용한다.(최신 브라우저들은 대부분 6~8개의 병렬커넥션 지원)
- 병렬 커넥션은 더 빠르게 ‘느껴질 수’있다
    - 실제로 더 빠르게 내려받는 것은 아니지만, 화면에 여러개의 객체가 동시에 보이면서 내려받고 있는 상황을 볼 수 있기 때문에 사용자는 더 빠르게 내려받고 있는 것처럼 느낄 수 있다.

## 4.5 지속 커넥션

사이트의 지역성을 활용하기 위해 한번 맺어진 TCP 커넥션을 유지하여 트랜잭션 여러개를 만들 수 있다. 클라이언트나 서버가 커넥션을 끊기 전까지는 계속 유지된다.

지속커넥션과 병렬커넥션이 함께 사용될 때에 가장 효과적이다. 적은 수의 병렬 커넥션을 맺고 이걸 계속 유지한다. HTTP 버전별로 이를 위한 커넥션이 마련되어있다.

지속 커넥션을 인식하지 못하는 이전 버전의 프락시 서버를 ‘dumb proxy’ 라고 부른다. 클라이언트 입장에서는 계속 유지되고 있는 커넥션으로 요청을 보내지만 프락시 서버는 그 요청을 무시해버리기 때문에, 브라우저는 자신이나 서버가 타임아웃이 나서 커넥션이 끊길 때까지 기다리게 된다. 즉, 프락시 서버에서 keep-alive 을 명확히 구현하는 것이 중요하다.

## 4.6 파이프라인 커넥션

HTTP/1.1 은 지속 커넥션을 통해 요청을 파이프라이닝할 수 있다.

하나의 트랜잭션이 끝날때까지 기다릴 필요없이 곧바로 다음 트랜잭션을 시작할 수 있다. 

- 고려사항
    - 클라이언트는 커넥션이 언제 끊어지더라도 완료되지 않은 요청이 파이프라인에 있으면 언제든 다시 요청을 보낼 준비가 되어있어야 한다.
    - 파이프라인을 통해 보낸 요청 중 일부만 실패했을 때 클라이언트는 어떤 요청이 실패했는지 알 수 없다. 재시도를 위해 멱등성이 없는 POST 요청을 재차 보내면 문제가 생길 수 있기 때문에 이런 요청을 보내지 말아야 한다.

## 4.7 커넥션 끊기에 대한 미스터리

커넥션 관리(특히 언제 커넥션을 끊는가)에는 명확한 기준이 없다.

TCP 커넥션은 양방향이다. 양쪽에는 데이터를 읽거나 쓰기 위한 입력큐와 출력큐가 있다.

- 전체 끊기와 절반 끊기
    - TCP 입력 채널과 출력 채널 중 한개만 끊거나 둘다 끊을 수 있다.
    - 출력채널이나 입력채널 둘 중 한 곳만 끊는 것이 절반 끊기이다.

일반적인 HTTP 애플리케이션은 서버 전체 끊기만 사용할 수 있다. 만약 클라이언트가 이미 연결이 끊긴 서버의 입력 채널로 데이터를 보낸다면 서버는 TCP `connection reset by peer` 메세지를 클라이언트한테 보낸다.

- 우아한 커넥션 끊기
    - 일반적으로 애플리케이션이 우아한 커넥션 끊기를 구현하는 것은 애플리케이션 자신의 출력채널을 먼저끊고 다른쪽에 있는 기기의 출력채널이 끊기는 것을 기다리는 것이다.

# 5장 웹서버

## 5.1 다채로운 웹 서버

웹 서버는 HTTP 요청을 처리하고 응답을 제공한다. 모든 웹 서버는 리소스에 대한 HTTP 요청을 받아서 콘텐츠를 클라이언트에게 돌려준다. 웹 서버는 HTTP 및 그와 관련된 TCP 처리를 구현한 것이다.

웹서버의 형태는 다양한데

1. 다목적 소프트웨어 웹서버
    1. 일반적인 컴퓨터에서 실행되는 서버를 말한다. 모든 인터넷 웹사이트의 37%가 마이크로소프트 웹서버, 35%가 아파치 웹서버, 14%가 nginx 서버를 통해 서비스 되고 있다.
2. 임베디드 웹서버
    1. 일반 소비자용 제품에 내장될 목적으로 만들어진 작은 웹 서버이다. e.g. 프린터나 가전제품

## 5.3 진짜 웹서버가 하는 일

1. 커넥션을 맺는다: 클라이언트의 접속을 받아들이거나, 원치 않는 클라이언트라면 닫는다.
2. 요청을 받는다: HTTP 요청 메세지를 네트워크로부터 읽어들인다.
3. 요청을 처리한다: 요청 메시지를 해석하고 행동을 취한다.
4. 리소스에 접근한다: 메시지에서 지정한 리소스에 접근한다.
5. 응답을 만든다: 올바른 헤더를 포함한 HTTP 응답 메시지를 생성한다.
6. 응답을 보낸다: 응답을 클라이언트에게 돌려준다.
7. 트랜잭션을 로그로 남긴다: 로그 파일에 트랜잭션 완료에 대한 기록을 남긴다.

## 5.4 단계 1: 클라이언트 커넥션 수락

이미 서버에 대해 열려있는 지속적 커넥션이 갖고있다면 그 커넥션을, 없다면 새 커넥션을 연다.

웹서버는 클라이언트의 정체를 밝혀서 커넥션을 맺을지 말지를 결정할 수 있다. 클라이언트의 IP 주소나 호스트명이 인가되지 않았거나 악의적이라고 판단된 경우 커넥션을 닫는다.

클라이언트의 호스트명을 알아내기 위해서는 **reverse DNS** 를 사용한다. 클라이언트의 IP주소를 클라이언트의 호스트명으로 변환하도록 설정되어있다.

## 5.5 단계 2: 요청 메시지 수신

커넥션에 데이터가 도착하면 웹서버는 그 데이터를 파싱하여 요청 메시지를 구성한다. 

- 요청줄을 파싱하여 요청 메서드, 지정된 리소스의 식별자(URI) , HTTP 버전번호 를 찾는다.
- 메세지 헤더들을 읽는다.
- 헤더의 끝을 의미하는 CRLF로 끝나는 빈줄을 찾아낸다. (존재 한다면)
- 요청 본문이 있다면, 읽어 들인다(길이는 Content-Length 헤더로 정의함)

## 5.6 단계 3: 요청처리

웹 서버가 요청을 받으면, 서버는 요청으로부터 메소드, 리소스, 헤더, 본문 (없는 경우도 있음)을 얻어내어 처리한다.

POST를 비롯한 몇몇 메소드는 요청 메세지에 엔티티 본문이 있을 것을 요구한다. GET과 같이 요청 메세지에 엔티티 본문이 있는 것을 금지하는 메소드도 있다.

## 5.7 단계 4: 리소스의 매핑과 접근

웹서버가 클라이언트에게 콘텐츠를 전달하려면, 그전에 요청 메시지의 URI에 대응하는 알맞은 콘텐츠나 콘텐츠 생성기를 웹서버에서 찾아서 그 콘텐츠의 원천을 식별해야한다.

- Docroot
    - 웹 서버가 클라이언트 요청의 URI를 실제 파일 경로로 매핑할 때 사용하는 **기준 디렉터리 경로.** 예를 들어, Docroot가 /var/www/html이면 GET /main.html 요청은 실제 파일 /var/www/html/main.html을 반환
- 디렉터리 목록
    - 웹 서버는, 경로가 파일이 아닌 디렉터리를 가리키는, 디렉터리의 URL에 대한 요청을 받을 수 있다
- 동적 콘텐츠 리소스 매칭
    - 웹 서버는 URI를 동적 리소스에 매핑 할 수도 있다. 요청에 맞게 콘텐츠를 생성하는 프로그램에 URI를 매핑 하는 것이다.

## 5.8 단계 5: 응답 만들기

한번 서버가 리소스를 식별하면, 서버는 요청 메소드로 서술되는 동작을 수행한 뒤, 응답 메세지를 반환한다.

응답 메세지는 응답 상태코드, 응답 헤더, 응답 본문(생성이 되었다면)을 포함한다.

- **응답 엔티티**
    - 만약 본문이 있다면 응답 메세지는 주로 다음을 포함한다.
        - 응답 본문의 MIME 타입을 서술하는 Content-Type 헤더
        - 응답 본문의 길이를 서술하는 Content-Length 헤더
        - 실제 응답 본문의 내용
- **MIME 타입 결정하기**
- **리다이렉션**
    - 웹 서버는 종종 성공 메세지 대신 리다이렉션 응답을 반환한다. 리다이렉션 응답의 상태 코드는 3XX 로 지칭된다.
    - **영구히 리소스가 옮겨진 경우**
    웹 서버는 클라이언트에게 리소스의 이름이 바뀌었으므로, 클라이언트는 북마크를 갱신하거나 할 수 있다고 말해 줄 수 있다.
    `301 Moved Pernanently` 상태 코드가 이런식의 리다이렉트를 위해 사용된다.
    - **임시로 리소스가 옮겨진 경우**
    만약 리소스가 임시로 옮겨지거나 이름이 변경된 경우 서버는 클라이언트를 새 위치로 리다이렉트 하기를 원한다.
    `303 See other, 307 Temporay Redirect` 상태 코드는 이런 경우에 사용된다
    - **URL 증강**
    서버는 종종 문맥 정보를 포함 시키기 위해 재 작성된 URL로 리다이렉트한다.
    `303 See other, 307 Temporay Redirect` 상태 코드를 사용한다.
    - **부하 균형**
    만약 과부화된 서버가 요청을 받으면, 서버는 클라이언트를 좀 덜 부하가 걸린 서버로 리다이렉트 할 수 있다.
    `303 See other, 307 Temporay Redirect` 상태 코드를 사용한다.
    - **친밀한 다른 서버가 있을 때**
    서버는 클라이언트를 그 클라이언트 대한 정보를 갖고 있는 다른 서버로 리 다이렉트 할 수 있다.
    `303 See other, 307 Temporay Redirect`상태 코드를 사용한다.

## 5.9 단계 6: 응답 보내기

웹 서버는 받을 떄와 마찬가지로 커넥션 너머로 데이터를 보낼 때도 비슷한 이슈를 직면한다.

서버는 커넥션 상태를 추적해야 하며 지속적인 커넥션은 특별히 주의해 사용할 필요가 있다.

비 지속적인 커넥션이라면, 서버는 모든 메세지를 전송했을 때 자신쪽의 커넥션을 닫을 것이다.

지속적인 커넥션이라면, 서버가 Content-Length 헤더를 바르게 계산하기 위해 특별한 주의를 필요로 하는 경우나, 클라이언트가 응답이 언제 끝나는지 알 수 없는 경우에 커넥션은 열린 상태를 유지할 것이다.

## 5.10 단계 7: 로깅

트랜잭션이 완료되었을 때 웹 서버는 트랜잭션이 어떻게 수행되었는지에 대해 로그를 로그파일에 기록한다.

# 6장 프락시

## 6.1 웹 중개자

웹 프락시 서버는 클라이언트의 입장에서 트랜잭션을 수행하는 중개인이다.

웹 프락시가 없다면, 클라이언트는 HTTP 서버와 **직접** 이야기한다.

웹 프락시가 있다면, 클라이언트는 HTTP 서버와 이야기하는 대신, 자신의 입장에서 서버와 대화해주는 **프락시**와 이야기한다.

트랜잭션을 완료하는 것이 클라이언트라는 점은 변하지 않지만, 프락시 서버가 제공하는 좋은 서비스를 이용하게 된다.

HTTP 프락시 서버는 웹 서버이기도 하고 웹 클라이언트이기도 하다. 프락시는 HTTP 클라이언트의 요청을 받게 되므로, 반드시 웹 서버처럼 요청과 커넥션을 적절히 다루고 응답을 돌려줘야 한다. 동시에 프락시는 요청을 서버로 보내기도 하므로, 요청을 보내고 응답을 받는 올바른 HTTP 클라이언트처럼 동작해야 한다

- 공용 프락시
    - 대부분의 프락시는 공용이며 **공유된** 프락시다. **중앙 집중형** 프락시를 관리하는 게 더 비용효율이 높고 쉽다. 그리고 캐시 프락시 서버와 같은 몇몇 프락시 애플리케이션은 프락시를 이용하는 사용자가 많을수록 유리하다
- 개인 프락시
    - 개인 전용 프락시는 그다지 흔하지는 않지만 꾸준히 사용되고 있다
    - 브라우저의 기능을 확장하거나 성능을 개선하거나 무료 ISP 서비스를 위한 광고를 운영하기 위해 작은 프락시를 사용자의 컴퓨터에서 직접 실행
- 프락시 vs 게이트웨이
    - `프락시`는 **같은** 프로토콜을 사용하는 둘 이상의 애플리케이션을 연결한다
    - `게이트웨이`는 **서로 다른** 프로토콜을 사용하는 둘 이상을 연결한다
        - 게이트웨이는 클라이언트와 서버가 서로 다른 프로토콜로 말하더라도 서로 간의 트랜잭션을 완료할 수 있도록 해주는 **프로토콜 변환기**처럼 동작한다.

## 6.2 왜 프락시를 사용하는가?

프락시 서버는 보안을 개선하고, 성능을 높여주며, 비용을 절약한다. 

그리고 프락시 서버는 모든 HTTP 트래픽을 들여다보고 건드릴 수 있기 때문에, 프락시는 부가적인 가치를 주는 여러 유용한 웹 서비스를 구현하기 위해 트래픽을 감시하고 수정할 수 있다.

- e.g.
    - 어린이 필터: 부적절한 사이트의 접근 강제 거부
    - 문서접근제어자: **감사 추적**(audit trail)을 하기 위해 사용. 기업 등에서..
    - 보안 방화벽: 네트워크 보안 엔지니어는 종종 보안을 강화하기 위해 프락시 서버를 사용
    - 웹캐시: 인기 있는 문서의 로컬 사본을 관리하고 해당 문서에 대한 요청이 오면 빠르게 제공하여, 느리고 비싼 인터넷 커뮤니케이션을 줄임
    - 대리 프락시: 진짜 웹 서버 요청을 받지만 웹 서버와는 달리 요청 받은 콘텐츠의 위치를 찾아내기 위해 다른 서버와 커뮤니케이션을 시작
    - 콘텐츠 라우터: 인터넷 트래픽 조건과 콘텐츠의 종류에 따라 요청을 특정 웹 서버로 유도하는 콘텐츠 라우터로 동작
    - 트랜스코더: 콘텐츠를 클라이언트에게 전달하기 전에 본문 포맷을 수정
    - 익명화 프락시: HTTP 메시지에서 신원을 식별할 수 있는 특성들(예: 클라이언트 IP 주소, From 헤더, Referer 헤더, 쿠키, URI 세션 아이디)을 적극적으로 제거함으로써 개인 정보 보호와 익명성 보장에 기여

## 6.3 프락시는 어디에 있는가?

어떻게 사용할지에 따라서 프락시는 어디에든 배치할 수 있다.

- 출구 프락시
    - 로컬 네트워크와 더 큰 인터넷 사이를 오가는 트래픽을 제어하기 위해 프락시를 로컬 네트워크의 출구에 박아 넣을 수 있다
    - 방화벽이나 부적절 콘텐츠 필터링
- 접근(입구) 프락시
    - 고객으로부터의 모든 요청을 종합적으로 처리하기 위해 프락시는 ISP 접근 지점에 위치하기도 한다.
    - 사용자들의 다운로드 속도를 개선하고 인터넷 대역폭 비용을 줄이기 위해 캐시 프락시를 사용해 많이 찾는 문서들의 사본을 저장한다.
- 대리 프락시
    - 대리 프락시는 네트워크의 가장 끝에 있는 웹 서버들의 바로 앞에 위치하여 웹 서버로 향하는 모든 요청을 처리하고 필요할 때만 웹 서버에게 자원을 요청할 수 있다.
- 네트워크 교환 프락시
    - 캐시를 이용해 인터넷 교차로의 혼잡을 완화하고 트래픽 흐름을 감시하기 위해, 충분한 처리 능력을 갖춘 프락시가 네트워크 사이의 인터넷 피어링 교환 지점들에 놓일 수 있다.

- 어떻게 **프락시가 트래픽을 처리하는가**
    - 클라이언트를 수정한다
        - 브라우저를 포함한 많은 웹 클라이언트들은 수동 혹은 자동 프락시 설정을 지원한다.
    - 네트워크를 수정한다
        - 네트워크 인프라를 가로채서 웹 트래픽을 프락시로 가도록 조정하는 몇 가지 기법이 있다.
    - DNS 이름공간을 수정한다
        - 웹 서버 앞에 위치하는 프락시 서버인 대리 프락시는 웹 서버의 이름과 IP 주소를 자신이 직접 사용한다. 그래서 모든 요청은 서버 대신 대리 프락시로 간다
    - 웹서버를 수정한다
        - 몇몇 웹 서버는 HTTP 리다이렉션 명령(응답 코드 305)을 클라이언트에게 돌려줌으로써 클라이언트의 요청을 프락시로 리다이렉트 하도록 설정할 수 있다.

## 6.4 클라이언트 프락시 설정

모든 현대적인 브라우저는 프락시를 사용할 수 있도록 설정할 수 있다. 사실 많은 브라우저가 프락시를 설정하는 여러 가지 방법을 제공한다.

- **수동 설정 (Manual Configuration)**
    - 사용자가 직접 **프락시 서버의 호스트와 포트**를 입력.
    - 예: 크롬 → 설정 > 네트워크 > 프록시 설정 변경
        
        IE → 도구 > 인터넷 옵션 > LAN 설정 → 프락시 서버 지정
        
    - **장점:** 단순함
    - **단점:** 모든 요청에 하나의 프락시만 사용 가능, 장애 시 대체 불가
- **브라우저 기본 설정**
    - 브라우저 제조사나 배포자가 미리 프락시를 설정해둠.
    - 기업 환경이나 ISP 제공 브라우저에서 자주 사용됨.
- **PAC (Proxy Auto-Configuration)**
    - 프락시 선택을 자동화하기 위한 **자바스크립트 파일(.pac)** 사용.
    - 브라우저는 PAC 파일 내의 FindProxyForURL(url, host) 함수를 실행해
        
        각 요청마다 어떤 프락시를 사용할지 결정함.
        
    - **장점:** 요청별 프락시 선택 가능, 장애 시 대체 경로 지정 가능, 대규모 환경 관리 용이
    - **단점:** PAC 파일의 위치(URI)는 여전히 수동으로 지정해야 함
- **WPAD (Web Proxy Auto-Discovery Protocol)**
    - PAC 파일의 위치조차 자동으로 찾아주는 프로토콜.
    - 브라우저는 WPAD를 통해 PAC 파일을 자동으로 탐색하고 실행함.

## 6.5 프락시 요청의 미묘한 특징들

- **프락시 URI는 서버 URI와 다르다**
    - 클라이언트가 프락시 대신 서버로 요청을 보내면 요청의 URI가 달라진다.
    - 클라이언트가 웹 서버로 요청을 보낼 때, 요청줄은 다음의 예와 같이 스킴, 호스트, 포트번호가 없는 부분 URI를 가진다.
        
        ```
        GET /index.html HTTP/1.0
        User-Agent: SuperBrowserv1.3
        ```
        
        그러나 클라이언트가 프락시로 요청을 보낼 때, 요청줄은 다음의 예와 같이 완전한 URI를 갖는다.
        
        ```
        GET http://www.marys-antiques.com/index.html HTTP/1.0
        User-Agent: SuperBrowser v1.3
        ```
        
    - why?
        - **초기의 HTTP 설계**에서는 클라이언트가 **하나의 서버와 직접 통신**했음.
        - 서버는 자신의 **호스트명과 포트번호**를 알고 있었기 때문에,
            
            클라이언트는 불필요한 정보를 생략하고 **부분 URI(path만)** 를 전송했음.
            
        - but 프락시 등장 후, **프락시 서버**는 클라이언트 대신 **다른 서버와 연결해야 하므로**,요청된 리소스의 **전체 주소(스킴, 호스트, 포트)** 를 알아야 함
        → 따라서 프락시에는 **완전한 URI** 가 필요함.
        
        ⇒ so http/1.0에서는 
        
        - **서버 요청**: 여전히 기존처럼 **부분 URI** 사용 (기존 서버와의 호환성 때문)
        - **프락시 요청**: **완전한 URI** 사용하도록 명세함
- **가상 호스팅에서 일어나는 같은 문제**
    - **문제:** 가상 호스팅 서버는 여러 사이트를 한 서버(IP)에서 운영하므로, /index.html 요청만으로는 어떤 사이트를 요청했는지 알 수 없음.
    - **해결:**
        - **프락시:** 요청에 **완전한 URI** 포함 (http://example.com/...)
        - **가상 호스팅 서버:** 요청 헤더에 **Host 헤더**를 요구 (예: Host: example.com)
- **인터셉트 프락시는 부분 URI를 받는다**
    - 클라이언트가 프락시를 **명시적으로 설정하지 않아도**, 트래픽이 **대리(transparent) 프락시**나 **인터셉트 프락시**를 거칠 수 있음.
    - 이런 경우, 클라이언트는 자신이 **서버와 직접 통신 중이라고 착각**하므로 **부분 URI만 보냄** (/index.html).
    - 인터셉트 프락시는 네트워크 흐름을 가로채 요청을 처리하거나 캐시된 응답을 반환함.
- **프락시는 프락시 요청과 서버요청을 모두 다룰 수 있다**
    - 프락시는 **완전 URI**와 **부분 URI**를 모두 처리할 수 있어야 함.
    - **규칙**
        1. **완전한 URI**가 있으면 그대로 사용.
        2. **부분 URI + Host 헤더** → Host 헤더로 서버명·포트 추출.
        3. **부분 URI + Host 헤더 없음** → 다음 순서로 판단 시도:
            - 프락시가 대리 프락시라면, 내부 설정된 서버 주소 사용.
            - 인터셉트 프락시라면, 이전 단계에서 저장된 원 서버 IP/포트 사용.
            - 둘 다 불가하면, 에러 반환 (보통 “Host 헤더를 지원하는 브라우저로 업그레이드하라”는 메시지).
- **전송 중 URI 변경**
    - 프락시는 요청을 전달할 때 **URI를 임의로 수정하면 안 됨**. (e.g. 포트 추가 :80, 인코딩 변경 등은 호환성 문제 초래 가능)
    - **HTTP 명세:** 프락시는 URI의 절대 경로를 수정해서는 안 되며, 유일한 예외는 **빈 경로를 “/“로 바꾸는 경우**뿐.
- **URI 자동 확장과 호스트명 해석**
    - 프락시가 **없을 때**, 브라우저는 직접 호스트 이름을 **DNS로 해석**.
    - **자동 확장 기능:**
        - 사용자가 yahoo 입력 → 브라우저가 자동으로 www.yahoo.com 시도.
        - 해석 실패 시, **오타 교정 사이트**나 **도메인 자동 추가** 기능(DNS 검색 규칙) 활용.
        - e.g. host7 입력 시 DNS가 host7.oreilly.com 시도.
- **프락시 없는 URI 분석**
    1. 사용자가 oreilly 입력.
        
        → 기본 스킴 http://, 기본 포트 80, 기본 경로 / 가정.
        
    2. oreilly 호스트 탐색 (실패).
    3. 자동 확장 → www.oreilly.com 탐색 (성공).
    4. 브라우저가 www.oreilly.com으로 연결 성공.

## 6.6 메시지 추적

- **Via 헤더**
    - 메시지가 지나간 **모든 중간 노드(프락시·게이트웨이)** 의 정보를 나열함.
    - 각 노드는 요청이나 응답을 전달할 때 **자신의 정보를 Via 헤더 끝에 추가**해야 함.
    
    ```graphql
    Via: 1.1 proxy-62.irenes-isp.net, 1.0 cache.joes-hardware.com
    ```
    
    - 첫 번째 프락시: HTTP/1.1 사용
    - 두 번째 프락시: HTTP/1.0 사용
- **TRACE 메서드**
    - 메시지가 프락시를 거치며 **어떻게 변형되었는지 추적**하기 위한 HTTP 메서드.
    - 프락시 체인을 **디버깅**하거나 **상호운용성 문제**를 진단할 때 사용.
    - 동작
        1. 클라이언트가 TRACE 요청 전송.
        2. 목적지 서버에 도착하면 서버는 **요청 메시지 전체를 본문에 담아 그대로 반환.**
        3. 클라이언트는 응답의 Via 헤더를 통해 어떤 프락시를 거쳤는지 확인 가능.
        4. 응답의 Content-Type: message/http, 상태 코드: 200 OK.
    - **Max-Forwards 헤더**
        - TRACE나 OPTIONS 요청이 **몇 번 더 다음 프락시로 전달될 수 있는지** 제한함.
        - **무한 루프 방지** 및 **특정 홉 테스트**용으로 사용.

## 6.7 프락시 인증

프락시는 접근 제어 장치로서 제공될 수 있다. HTTP는 사용자가 유효한 접근 권한 자격을 프락시에 제출하지 않는 한 콘텐츠에 대한 요청을 차단하는 프락시 인증이라는 메커니즘을 정의하고 있다.

- 제한된 콘텐츠에 대한 요청이 프락시 서버에 도착했을 때, 프락시 서버는 접근 자격을 요구하는 `407 Proxy Authorization Required` 상태 코드를 어떻게 그러한 자격을 제출할 수 있는지 설명해주는 `Proxy-Authenticate` 헤더 필드와 함께 반환할 수 있다.
- 클라이언트는 **407 응답**을 받게 되면, 로컬 데이터베이스를 확인해서든 사용자에게 물어봐서든 **요구되는 자격을 수집**한다.
- 자격을 획득하면, 클라이언트는 요구되는 자격을 `Proxy-Authorization 헤더 필드`에 담아서 요청을 다시 보낸다.
- **자격이 유효**하다면, 프락시는 원 요청을 **연쇄를 따라 통과**시킨다. 유효하지 않다면 407 응답을 보낸다.

## 6.8 프락시 상호운용성

클라이언트, 서버, 프락시는 HTTP 명세의 여러 버전에 대해 여러 벤더에 의해 만들어진다. 

그들이 지원하는 여러 가지 기능을 지원하며 제각각 다른 버그를 갖고 있다. 프락시 서버는 서로 다른 프로토콜을 구현했을 수도 있고 골치 아프게 이상한 동작을 할 수도 있는 클라이언트와 서버 사이를 중개해야 한다.

- 지원하지 않는 헤더와 메서드 다루기
    - 프락시는 이해할 수 없는 헤더 필드는 반드시 그대로 전달해야 하며, 같은 이름의 헤더 필드가 여러 개 있는 경우에는 그들의 상대적인 순서도 반드시 유지해야 한다.
    - 만약 프락시가 어떤 메서드와 친숙하지 않다면, 가능한 한 그 메시지를 다음 홉으로 전달하려 시도해야 한다.
- OPTIONS: 어떤 기능을 지원하는지 알아보기
    - HTTP OPTIONS 메서드는 서버나 웹 서버의 **특정 리소스가 어떤 기능을 지원하는지** 클라이언트(혹은 프락시)가 알아볼 수 있게 해준다
    - 서로 다른 기능 수준의 서버와 프락시가 더 쉽게 상호작용할 수 있도록 클라이언트는 OPTIONS를 이용해 서버의 능력을 먼저 알아낼 수 있다.
- Allow 헤더
    - 요청 URI에 의해 식별되는 자원에 대해 지원되는 메서드들이나 서버가 지원하는 모든 메서드(요청 URI가 별표인 경우)를 열거한다 (e.g. Allow: GET, HEAD, PUT)
    - Allow 헤더는 새 리소스가 지원했으면 하는 메서드를 추천하기 위해 요청 헤더로 사용될 수 있다. 서버는 추천 받은 메서드를 모두 지원해야 할 의무는 없으며, 그 요청에 대한 응답에는 실제로 지원하는 메서드들을 열거하는 Allow 헤더를 포함시켜야 한다.
    - 만약 프락시가 지정된 모든 메서드를 이해할 수는 없다고 해도, 프락시는 Allow 헤더 필드를 수정할 수 없다. 왜냐하면 클라이언트는 원 서버와 대화하는 다른 경로를 갖고 있을 수도 있기 때문이다.
