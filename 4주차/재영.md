# 🕙 HTTP 완벽 가이드 10장(HTTP/2.O) 🕙

## HTTP/2.0 등장 배경

- HTTP/1.1의 메시지 포맷은 구현의 단순성과 접근성에 주안점을 두고 최적화 => 성능 희생
  - 커넥션 하나를 통해 요청 하나를 보내고 그에 대한 응답 하나를 받는 방식
  - 응답을 받아야만 다음 요청 전송 가능 => 회전 지연
  - 병렬 커넥션 & 파이프라인 커넥션은 근본적인 해결책 X
- 이를 해결하기 위한 SPDY 프로토콜

  - 헤더를 압축하여 대역폭 절약
  - 요청이 없어도 서버가 능동적으로 리소스 푸시

- HTTP/2.0은 SPDY를 기반으로 설계
- 실제로 RTT 감소

## HTTP/2.0

- 서버와 클라이언트 사이의 TCP 커넥션 사이에서 동작
- 요청과 응답은 16383바이트로 정의된 1개 이상의 프레임에 저장, 헤더는 압축해서 저장(허프만 알고리즘)
- 요청과 응답은 스트림을 통해서 전송, 1개의 스트림이 요청과 응답 한 쌍을 처리
- 하나의 TCP 커넥션 위에 여러 스트림이 동시에 생성 가능, 여러 요청과 응답을 동시에 처리 가능!
- 스트림에 대한 흐름 제어와 우선순위 부여 기능 제공
- 서버 푸시 모델 도입(하나의 요청에 대해 응답으로 여러 개의 리소스를 보내는 것)
- 호환성 유지를 위해 HTTP/1.1과 요청 응답 메시지의 의미 통일

- 헤더는 표현 방법이 바뀜
  - Content-Length => :content-length
  - 404 Not Found => :status (404 값을 가짐)

## 바이너리 프레이밍 계층

- 바이너리 프레이밍 계층은 HTTP 메시지가 캡슐화되어 전송되는 방식 규정
- HTTP/2.0은 기존보다 더 작은 메시지와 프레임으로 분할되어 바이너리 형식으로 인코딩
- HTTP/1과 HTTP/2는 서로를 이해하지 못하지만 통신이 가능 => 프레이밍 작업을 클라이언트와 서버가 대신 하기 때문에 서비스 자체는 이 모든 변경을 인식할 필요 없음

## 스트림, 메시지, 프레임

### 스트림

- HTTP/2.0 커넥션을 통해 클라이언트, 서버 사이에 교환되는 프레임들의 독립된 양방향 시퀀스
- 모든 스트림은 고유한 식별자를 가짐
- 협상 과정에서 TCP 패킷 주고받을 필요 X

### 메시지

- 논리적 요청 또는 응답 메시지에 맵핑되는 프레임의 전체 시퀀스

### 프레임

- 통신의 최소 단위, 하나의 프레임 헤더 포함, 최소한으로 프레임이 속하는 스트림 식별

- 모든 통신은 단일 TCP 연결을 통해 수행
- 전달 가능한 스트림 수는 제한 X
- 스트림에는 고유 식별자와 우선순위 정보가 있음
- 메시지는 하나 이상의 프레임으로 구성
- 프레임은 특정 유형의 데이터를 전달
- 다른 스트림들의 프레임을 인터리빙한 다음 각 프레임 헤더에 삽입된 스트림 식별자를 통해 프레임에 재조립도 가능

## 헤더 압축

- 중복되는 헤더들을 압축하면 성능 증가
- 허프만 알고리즘을 사용해 헤더 압축
- 압축을 못푼다면 COMPRESSION_ERROR와 함께 연결 종료

## 서버 푸시

- 하나의 요청에 여러 리소스 전송 가능(푸시 방식)
- PUSH_PROMISE 프레임을 보내 여러 리소스를 푸시할 것을 알려야 함
- 클라이언트는 RST_STREAM으로 PUSH_PROMISE 거절 가능

# 🕚 HTTP 완벽 가이드 11장(클라이언트 식별과 쿠키) 🕚

## 개별 접촉

- 현대의 웹 서비스는 개인화된 서비스 제공을 원함
- 여러 서비스는 서비스를 개인화하여 사용자에게 제공

### 개별 인사

- 사용자에게 특화된 메시지나 페이지

### 사용자 맞춤 추천

- 흥미에 따른 추천
- 생일에 특별한 제품 제시

### 저장된 사용자 정보

- 주소 및 신용카드 정보를 저장하여 매번 입력하지 않도록 함
- 서비스를 더 편하게 이용하게 하기 위해 정보 사용

### 세션 추적

- 서비스는 각 사용자에게서 오는 HTTP 트랜잭션 식별이 필요

## HTTP 헤더

### From => 사용자의 이메일 주소

- 이메일 주소로 사용자 식별 가능
- 악의적 서버가 스팸 메일을 발송하는 문제로 From 헤더를 보내는 브라우저는 적음

### User-Agent => 사용자의 브라우저

- 브라우저의 이름, 버전 정보, 운영체제 등
- 특정 브라우저에서 제대로 동작하도록 최적화
- 사용자 식별은 불가

### Referer => 사용자가 현재 링크를 타고 온 근원 페이지

- 사용자가 전에 방문했던 페이지 식별
- 웹 사용 형태나 취향 파악

위는 사용자 식별이 용이하지 않음

- Authorization => 사용자 이름과 비밀번호
- Client-Ip => 클라이언트의 IP 주소
- X-Forwarded-For => 클라이언트의 IP 주소
- Cookie => 서버가 생성한 ID 라벨
  아래에서 추가 설명

### 클라이언트 IP

- 웹 서버는 HTTP 요청을 보내는 TCP 커넥션의 반대쪽 IP 취득 가능
- 사용자 컴퓨터를 가리킴 => 여러 사람이 한 컴퓨터 이용시 식별 불가
- 많은 사용자가 NAT 방화벽을 통해 IP 주소 변환
- 프록시와 게이트웨이로 인한 클라이언트 IP 취득 불가

## 사용자 로그인

- 로그인을 통한 명시적 식별 요청
- Authorization 헤더를 통해 사용자 이름을 전달하는 체계
- 서버에서 사용자가 사이트에 접근하기 전에 로그인을 시키고자 한다면 HTTP 401 Login Required 응답 코드를 브라우저에 보냄(??? 뭔 말이지 그냥 로그인 페이지부터 보여주면 되는거 아닌가?)
  <a href="https://ibb.co/Tx7d6py1"><img src="https://i.ibb.co/JwGgV0Zq/image.png" alt="image"></a>
- HTTP 프로토콜 레벨의 인증 방식
- 이후 요청부터 Authorization 헤더에 해당 정보 입력하여 전송
- 매번 인증 요청을 해야되는 번거로움 => 쿠키로 해결

## 뚱뚱한 URL

- 사용자 정보가 포함된 URL

## 쿠키

- 사용자를 식별하고 세션을 유지하는 방식
- 쿠키에 있는 내용물은 보통 캐싱하지 않음

### 쿠키 타입

1. 세션 쿠키

- 사용자가 사이트를 탐색할 때, 설정과 선호 사항을 저장하는 임시 쿠키
- Discard 설정 O / 남은 시간 설정 X => 세션 쿠키

2. 지속 쿠키

- 디스크에 저장, 재시작해도 남음
- 사이트에 대한 설정 정보 및 로그인 정보 유지

3. 시큐어 쿠키

- HTTPS에서만 사용 가능
- 쿠키 정보가 암호화

4. 써드파티 쿠키

- 방문한 도메인과 다른 도메인에서 발급된 쿠키
- 주로 광고 및 선호 파악용 트래킹에 사용

### 쿠키 동작

- 사용자가 이후에 다시 서버에 접근했을 때, 해당 사용자를 식별하기 위한 유일한 값을 쿠키에 할당
- 쿠키는 임의의이름=값 형태의 리스트, 해당 리스트는 Set-Cookie와 같은 응답 헤더에 저장되어 전달
- id="34294"라는 쿠키를 사용자에게 할당하면 이 값으로 db에 사용자 정보를 찾는데 사용

### 클라이언트 상태

- 브라우저는 쿠키 정보를 저장할 책임이 있음
- 이 시스템을 클라이언트 상태라고 부름

### 쿠키 Domain

- Set-Cookie 헤더에 도메인을 작성하여 어떤 사이트에서 그 쿠키를 읽을 수 있는지 제어 가능
- domain="naver.com"이면 해당 사이트에서 Cookie 헤더가 적용
- 💡만약 domain=".naver.com"이라면? .이 앞에 붙으면 서브 도메인도 모두 적용!

출처 : https://cjy3458.tistory.com/50

### 쿠키 Path

- Path를 작성하여 해당 경로에 속하는 페이지만 쿠키 전달
- path=/data

  - /data/v1 접근 가능
  - /data/v412 접근 가능
  - /dataritararara 접근 불가능

- 즉 클라이언트는 쿠키를 유효한 사이트에만 전달하고 관리

### Set-Cookie 속성

필드 속성 설명
NAME=VALUE 쿠키에 부여된 이름과 값 (필수)
Expires=DATE 쿠키 유효 기한
Path=PATH 쿠키 적용 대상이 되는 디렉토리
Domain=도메인명 쿠키 적용 대상이 되는 도메인 명
Secure HTTPS로 통신하는 경우에만 쿠키를 송신
HttpOnly 쿠키를 자바스크립트에서 액세스하지 못하도록 제한
SameSite 크로스 사이트 요청 시 서드 파티 쿠키 전송을 제한

출처 : https://cjy3458.tistory.com/50

### 쿠키와 캐싱

캐시 쿠키 기본 원칙

1. 캐시되지 말아야 할 문서가 있다면 표기하라
2. Set-Cookie 헤더를 캐싱하는 것에 유의하라
3. Cookie 헤더를 가지고 있는 요청을 주의하라

# 🕛 HTTP 완벽 가이드 12장(기본 인증) 🕛

## 인증 프로토콜과 헤더

- 인증은 내가 누구인지 증명하는 것
- HTTP에는 기본 인증과 다이제스트 인증이 있음

## 4가지 인증 단계

1. 요청 -> 헤더 없음 -> GET
2. 인증 요구 -> WWW-Authenticate 헤더 -> 401 상태와 함께 요청 반려(프록시면 407 상태) -> 401 Unauthorized
3. 인증 -> Authorization 헤더 -> 사용자 이름과 비밀번호가 작성된 헤더와 함께 요청 -> GET
4. 성공 -> Authentication-Info -> 인증 정보 확인 후 리소스와 함께 응답 -> 200 OK

## 보안 영역

- WWW-Authenticate 헤더에 보안 영역을 작성
- 보안 영역은 realm으로 표현 realm="Jae Young Money"

## 프록시 인증

- 프록시 서버에서 접근 정책을 중앙 관리할 수도 있음
- 중개 프록시를 이용한 인증
- 헤더명 및 상태 코드가 좀 다름

## 기본 인증의 보안 결함

- HTTPS나 다이제스트를 쓰는게 훨씬 나음
