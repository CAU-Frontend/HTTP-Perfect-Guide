# HTTP 2.0
## 등장 배경
1.1의 성능 개선
-> 회전 지연 문제를 해결하기 위해서. 

### 회전지연
응답을 받아야 다음 요청을 보낼 수 있는 문제

## 개요
TCP 커넥션 사이에서 동작함
커넥션 초기화는 클라이언트가 수행함
요청/응답은 길이가 정의된 한 개 이상의 프레임에 담김
이는 스트림을 통해 보내짐

### 서버푸시
서버는 클라이언트에게 필요하다고 생각되는 데이터를 보내줄 수 있음

### 프레임
HTTP2.0의 모든 메시지는 프레임에 담겨 전송됨
모든 프레임은 8바이트 크기의 헤더로 시작함
뒤이어 최대 16383바이트 크기의 페이로드가 옴

### 스트림
HTTP 2.0커넥션을 통해 클라이언트-서버사이에서 교환되는 프레임들의 독립된 양방향 시퀀스
한쌍의 HTTP요청과 응답은 하나의 스트림으로 이뤄짐

원래는 응답이 와야 다시 요청이 가능하나, HTTP2.0에서는 하나의 커넥션에 여러개의 스트림을 여는 방식으로 해결함
스트림은 우선순위를 가질 수 있음
모든 스트림은 고유한 식별자를 가지며, 서버와 클라이언트는 상대방과 협상없이 일방적으로 스트림을 만듦.
고유 식별자는 재사용될 수 없음

### 헤더압축
HTTP 2.0은 HTTP 메시지 헤더를 압축해서 전송함
헤더는 HPACK명세에 정의된 헤더 압축방법으로 압축됨. 그리고 이걸 헤더 블록조각으로 쪼개어서 송신함
수신자는 이를 받아서 압축해제해서 사용
압축시에는 압축 콘텍스트를 사용함

### 서버 푸시
서버가 하나의 요청에 대한 응답으로 여러개의 리소스를 보낼 수 있게해줌
리소스 푸시서버는 클라이언트에게 자원을 푸시할 것임을 PUSH_PROMISE 프레임을 보내서 미리 알려줘야함
해당 프레임의 스트림은 클라에서 예약됨 상태가 됨 -> RST_STREAM으로 거절 가능

1. 서버 푸시를 사용하기로 했더라고 프록시가 전달하지 않을 수 있음
2. 서버는 안전하고, 캐시 가능하고, 본문을 포함하지 않은 요청에 대해서만 푸시 가능
3. 푸시 리소스는 클라이언트가 명시적으로 보낸 요청과 연관되어야함
4. 브라우저는 SOP정책에 따라 리소스를 검사함
5. 끄려면 SETTINGS_ENABLE_PUSH를 0으로 설정하면됨

# 클라이언트 식별과 쿠키

## 개별접촉
HTTP는 익명, 무상태 프로토콜이라서 식별하기가 어려움
이를 해결하는 기술들에 대해 다룸

## HTTP헤더
1. From : 사용자의 이메일 주소
2. User-Agent: 사용자의 브라우저 정보
3. Referrer: 사용자가 현재 링크를 타고 온 근원 페이지
4. Authorization : 사용자 이름과 비밀번호
5. Client-ip : 클라이언트 IP주소
6. X-Forwarded-For : 클라이언트의 IP주소
7. Cookie: 서버가 생성한 ID라벨


## 사용자 로그인
WWW-Authenticate, Authorization 헤더를 사용함
한번 로그인하면, 브라우저는 사이트에 대한 모든 요청에 대해 이 정보를 함께 보냄

## URL
URL -> 유저 상태 정보를 URL을 통해 세션으로 추적하기도함
여러 문제가 있음
1. 못생긴 URL
2. 공유하지 못하는 URL
3. 캐시로 만들 수 없음
4. 서버 부하 가중
5. 이탈

## 쿠키
어떤 정보든 담을 수 있다.
브라우저가 서버로부터온 Set-Cookie, Set-Cookie2 헤더에 있는 쿠키 콘텐츠를 브라우저 쿠키 DB에 저장함
사용자가 미래에 같은 사이트를 방문하면, 이 쿠키를 Cookie헤더에 동봉해서 요청함

1. 세션쿠키
2. 지속쿠키 (persistent)

### 세션쿠키
사용자가 사이트 탐색시 관련 설정과 선호 사항을 저장하는 임시 쿠키 -> 브라우저 닫으면 삭제됨
쿠키에 Discard나 Expires, Max-Age가 없으면 세션쿠키임

### 지속쿠키
PC를 껐다가 켜도 남아있음

### 쿠키
1. creation_utc : 쿠키 생성 시점
2. host_key : 쿠키 도메인
3. name : 쿠키 이름
4. value: 쿠키 값
5. path: 크키 관련 도메인 경로
6. expire_utc : 쿠키 파기 시점
7. secure: SSL커넥션일때만 보낼지 결정


## 쿠키 전송
브라우저는 각 사이트에 2-3개의 쿠키만을 보냄
1. 모두 보내면 성능이 크게 저하됨
2. 개인정보 문제

### domain
서버는 Set-Cookie응답 헤더에 Domain 속성을 기술해서 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어할 수 있음

### path
url 경로의 앞부분을 가리키는 path속성을 기술해서 해당 경로에 속하는 페이지에만 쿠키를 전달하기도함

## 쿠키 구성요소
version 0쿠키, version 1쿠키가 있음

## 쿠키와 캐싱
### 캐싱 원칙
1. 캐시되지 말아야할 문서를 표기할 것
2. Set-Cookie 헤더를 캐시하는 것에 유의
    -> 또한 특정 캐시가 Set-Cookie를 제거해서 클라이언트가 인증에 실패하는 경우에 유의해야함



