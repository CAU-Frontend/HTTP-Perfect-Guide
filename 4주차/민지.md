# 10장 HTTP/2.0

## 10.1 HTTP/2.0의 등장 배경

HTTP/1.1의 메시지 포맷은 구현의 단순성과 접근성의 최적화

커넥션 하나를 통해 요청 하나를 보내고 그에 대해 응답 하나만을 받는 방식 → 단순

but 응답이 오고 나서 다음 요청을 받을 수 있었기에 레이턴시가 존재함.

2009년 구글에서 빠른 웹을 만들고자 SPDY(스피디) 프로토콜 개발.

- 헤더 압축해 대역폭 절약하고
- 하나의 TCP 커넥션에 여러 요청을 동시에 보내 레이턴시를 줄이고
- 클라이언트가 요청을 보내지 않아도 서버가 능동적으로 리소스를 푸시하는 기능도 추가

→ 실제로 스피디를 적용했을 때 RTT가 큰 상황일 수록 26% 이상의 개선 효과가 있었음

이후 SPDY를 기반으로 HTTP/2.0 작업이 진행

## 10.2 개요

HTTP/2.0는 TCP 커넥션 위에서 동작. TCP 커넥션을 초기화하는 것은 클라이언트.

HTTP/2.0 요청과 응답은 길이가 정의된 한 개 이상의 프레임에 담기고 이때 HTTP 헤더는 압축

프레임에 담긴 요청과 응답은 스트림을 통해서 보내지고. 한개의 스트림이 한쌍을 처리함.

하나의 커넥션 위에 여러개의 스트림이 동시에 만들어질 수 있음 → 여러개의 요청과 응답 동시 처리 가능.

HTTP/2.0은 스트림에 대한 흐름 제어와 우선순위 부여 기능도 제공

## 10.3 HTTP/1.1과의 차이점

- **프레임**
    - HTTP/2.0은 모든 메시지를 프레임에 담아서 전송
        - HTTP/1.1은 프레임이라는 개념없이 텍스트 헤더 + 바디 구조
    <img width="998" height="446" alt="image" src="https://github.com/user-attachments/assets/7db7382a-1563-44bd-b190-d0034df42f00" />
    
- **스트림과 멀티 플렉싱**
    - **스트림**은 HTTP/2.0 커넥션을 통해 클라이언트와 서버 사이에 교환되는 프레임들의 독립된 양방향 시퀀스
    - 클라이언트가 새 스트림을 만들어 요청을 보내면 요청 받은 서버는 그 요처오가 같은 스트림으로 응답을 보냄. 스트림 닫힘 욧
    - HTTP/1.1에서는 한 TCP 커넥션을 통해 요청을 보냈을때 그에 대한 응답이 와야 보낼 수 있었음 → 그래서 예전에는 레이턴시 줄이려고 커넥션을 많이 만들어서 동시에 보내는 방식을 했었음.. but 무한정 만들수는 없다.
    - HTTP/2.0의 스트림을 통해서 각 쌍을 식별할 수 있게되어 커넥션 하나로도 동시에 열릴수가 있게됨.
        - 스트림 우선순위 설정도 가능. 의무사항은 아님
        - 31비트 무부호 정수로된 고유 식별자를 갖는다
        - 스트림이 클라이언트로부터 초기화됐다면 식별자는 홀수여야함. 서버는 짝수
        - 새로 만들어지는 스트림은 이전 식별자들보다 커야함.
        - 서버와 클라이언트는 협상없이 스트림을 일방적으로 만들어 시간 낭비가 없게함
        - 한번 사용한 스트림 재사용 불가. 커넥션을 오래 맺으면 고갈될수있는데 이런 경우에는 커넥션 다시 맺음
- **헤더 압축**
    - HTTP/1.1에서는 헤더 압축없이 그대로 전송 → 레이턴시 대역폭 영향
    - HTTP/2.0에서는 헤더 합축해 전송.
        - 압축하고 해제할 때 압축 콘텍스트를 사용. 수신한 헤더의 압축을 풀면 압축 콘텍스트가 바뀜. 오동작하지 않도록 헤더를 받은 수신측은 어떤 경우에도 반드시 압축해제를 수행해야함. 그럴 수 없다면 COMPRESSION_ERROR로 함께 커넥션 끊음
- **서버 푸시**
    - 서버가 하나의 요청에 대해 응답으로 여러개의 리소스를 보낼 수 있도록 해줌.
    - 서버가 클라이언트에서 어떤 리소스를 요구할 것인지 미리 알 수 있는 상황에서 유용
    - 리소스를 푸시하려는 서버는 먼저 클라이언트한테 자원을 푸시할 것임은 PUSH_PROMISE 프레임을 보내서 알려줌. 클라이언트가 이 프레임을 받게 되면 해당 프레임의 스트림은 예약된 상태가 됨. 이 상태에서 클라이언트는 RST_STREAM 프레임을 보내서 푸시 거절 가능. 스트림이 닫히기 전까지 클라이언트는 서버가 푸시하려고 하는 리소스를 요청해서는 안됨.
    - 서버 푸시를 끄고 싶다면 SETTING_ENABLE_PUSH를 0으로 설정

## 10.4 알려진 보안 이슈

- **중개자 캡슐화 공격(Intermediary Encapsulation Attacks)**
    - HTTP/2.0은 헤더 필드로 어떤 문자열이든 허용 → 따라서 HTTP/2.0 메시지를 중간의 프록시가 HTTP/1.1로 변환할 때 메시지가 위조될 가능성이 있음 (반대로 HTTP/1.1 → 2.0으로 변환할 때는 이런 문제가 없음)
- **긴 커넥션 유지로 인한 개인정보 누출 우려**
    - HTTP/2.0은 1.1보다 훨씬 긴 시간 커넥션을 유지한다. 어떤 사용자가 브라우저를 사용할 때 그 사용자는 이전에 브라우저를 사용했던 사용자가 무엇을 했는지 알아낼 가능성이 있음

# 11장 클라이언트 식별과 쿠키

## 11.1 개별 접촉

현대의 웹사이트들은 개인화된 서비스 제공하고 싶어함. 여러 방식으로 사이트를 개인화시켜서 사용자에게 제공

- 개별 인사 - 사용자가 접속하면 특화된 환영 메시지나 페이지 내용 만듦
- 사용자 맞춤 추천 - 고객 생일이나 중요한 날 흥미 같은거 학습해서 추천
- 저장한 사용자 정보 - 고객의 주소나 신용카드 정보 저장
- 세션 추적 - 장바구니 기능을 위해서 사용자 상태 저장

## 11.2 HTTP 헤더

| **헤더 이름** | **헤더 타입** | **설명** |
| --- | --- | --- |
| From | 요청 | 사용자의 이메일 주소 |
| User-Agent | 요청 | 사용자의 브라우저 |
| Referer | 요청 | 사용자가 현재 링크를 타고온 근원 페이지 |
| Authorization | 요청 | 사용자 이름과 비밀번호 |
| Client-ip | 확장(요청) | 클라이언트 IP주소 |
| X-Forwarded-For | 확장(요청) | 클라이언트 IP주소 |
| Cookie | 확장(요청) | 서버가 생성한 ID 라벨 |

## 11.3 클라이언트 IP 주소

초기 웹 선구자들은 사용자 식별에 있어 IP 주소를 사용하려 했음. 하지만 IP주소로 사용자를 식별하는 방식은 다음과 같은 약점이 있어 인트라넷 같이 제한된 영역에서는 사용하기도 하지만, 그 외에는 사용하지 않음

- 식별할 수 없는 경우
    - 여러 사용자가 같은 컴퓨터를 사용 할 때
    - 인터넷 서비스 제공자(ISP)가 사용자가 로그인할 때 동적으로 IP 주소를 할당하는 경우
    - 보안강화를 위해 사용자가 네트워크 주소 변환(NAT)방화벽을 사용할 경우
    - 웹 서버가 클라이언트 IP주소 대신 프락시 서버의 IP주소를 볼 경우

## 11.4 사용자 로그인

웹 서버는 사용자 이름과 비밀번호로 인증(로그인)할 것을 요구해서 사용자에게 명시적으로 식별 요청을 할 수 있음

- 사용자 식별 요청
    1. 브라우저는 서버로 사이트 접근 요청을 보낸다
    2. 사이트는 401 Login Required HTTP 응답 코드와 WWW-Authenticate 헤더를 반환하여 로그인하라고 요청한다
    3. 사용자가 입력 후, 브라우저는 기존 요청을 다시 보내서 사용자 식별을 시도한다(Authenticate 헤더 사용)
    4. 서버는 사용자의 식별 정보를 안다
    5. 이 시점 이후, 브라우저는 서버로부터 사용자 식별 정보를 요청 받으면 자동으로 사용자 이름과 비밀번호를 전달한다.

## 11.5 뚱뚱한 URL

사용자의 상태 정보를 포함하고 있는 URL을 뚱뚱한 URL이라고 함

예를들어 Amazon.com에서는 웹 상점을 돌아다니는 사용자에게 할당된 식별번호를 각 URL뒤에 붙여 사용자를 추적

- 문제점
    - URL 이 사용자에게 혼돈을 준다
    - 공유하게 되면 개인정보 유출의 위험이 있다
    - URL이 달라지므로 기존 캐시에 접근할 수 없다
    - 뚱뚱한 URL을 위한 HTML페이지를 다시 그려야 한다
    - 다른 사이트로 이동하면 뚱뚱한 URL 세션에서 이탈할 수 있다. 이 경우 장바구니같은 것들이 초기화된다.
    - 로그아웃 할 시 모든 정보를 잃는다

## 11.6 쿠키

쿠키는 사용자를 식별하고 세션을 유지하는 방식 중에서 현재까지 가장 널리 사용하는 방식

아래 두가지로 나눌 수 있다.

- 세션 쿠키
    - 사용자가 사이트 탐색할 때, 관련한 설정과 신호 사항들을 저장하는 임시쿠키
    - 사용자가 브라우저를 닫으면 삭제됨
- 지속 쿠키
    - 디스크에 저장되어, 브라우저를 닫거나 컴퓨터를 재시작하더라도 남아있음.
    - 사용자가 주기적으로 방문하는 사이트에 대한 설정 정보나 로그인 이름을 유지하려고 사용

→ 둘을 파기되는 시점만 다름. Discard 파라미터가 설정되어있거나 Expires, Max-Age 파라미터 없으면 세션쿠키임

- 쿠키 동작
    - 사용자가 웹 사이트에 방문하면 웹 서버는 사용자에 대해 모름
    - 다시 돌아왔을 때, 해당 사용자를 식별하기 위한 유일한 값을 쿠키에 할당
        - 쿠키는 임의의 이름=값 형태의 리스트를 가지고, 리스트는 `Set-Cookie`같은 http 응답헤더에 기술되어 사용자에게 전달
    - 쿠키는 어떤 정보든 포함될 수 있음. 사용자가 미래에 같은 사이트를 방문하면, 브라우저는 서버가 이 사용자에게 할당했던 쿠키를 Cookie 요청헤더에 기술해 전송

- 쿠키 상자: 클라이언트 측 상태
    - 브라우저는 쿠키 정보를 저장할 책임이 있는데, 이 시스템을 '클라이언트 측 상태'라고 한다. 공식적인 이름은 'HTTP 상태 관리 체계'
    - 구글 크롬 쿠키
        - 구글 크롬은 Cookies라는 SQLite 파일에 쿠키를 저장
        - 한 행이 쿠키 한개에 해당
            - creation_utc : 쿠키가 생성된 사점
            - host_key : 쿠키의 도메인
            - name : 쿠키의 이름
            - value : 쿠키의 값
            - path : 쿠키와 관련된 도메인에 있는 경로다
            - expire_utc : 쿠키의 파기 시점
            - secure : 이 쿠키를 SSL 커넥션일 경우에만 보낼지를 가리킴
    - 마이크로소프트 인터넷 익스플로러 쿠키
        - 캐시 디렉터리에 개별 텍스트 파일로 저장
- 사이트마다 각기 다른 쿠키들
    - 브라우저는 쿠키를 생성한 서버에게만 쿠키에 담긴 정보를 전달한다.
    서버는 쿠키를 생성할 때, Set-Cookie 응답 헤더에 **Domain**속성을 기술해서 어떤 사이트가 그 쿠키를 읽을 수 있는지 제어함
        - `Set-Cookie: user="mary17"; domain="airtravelbargains.com"`
    - Path 속성으로 웹사이트 일부에만 쿠키 적용도 가능.
        - `Set-Cookie: pref=compact; domain="airtravelbargains.com"; path=/autos/`
- 쿠키 구성 요소
    - Version0 넷스케이프 쿠키
        
        
        | **Set-Cookie 속성** | 설명 | **예** |
        | --- | --- | --- |
        | 이름=값 | 필수 속성 | Set-Cookie: customer=Mary |
        | Expires | 선택 속성. 쿠키 생명주기를 가리키는 날짜 문자열 | Set-Cookie: foo=bar; expires=Wendsday, 09-Nov-99 23:12:40 GMT |
        | Domain | 선택 속성. 브라우저는 이 속성에 기술된 도메인을 사용하는 서버 호스트명으로만 쿠키를 전송 | Set-Cookie: SHIPPING=REDEX; domain="joes-hardware.com" |
        | Path | 선택 속성. 서버에 있는 특정 문서에만 쿠키 할당 | Set-Cookie: lastorder=00183; path:/orders |
        | Secure | 선택 속성. 쿠키는 HTTP가 SSL 보안 연결을 사용할 때만 쿠키 전송 | Set-Cookie: private_id=519; secure |
    - Version 1 (RFC 2965) 쿠키
        - 폐기됨
- 쿠키와 세션 추적
    - 쿠키를 사용하여 사용자 식별을 할 수 있으니 연속적인 트랜잭션이 가능
    <img width="482" height="575" alt="image2" src="https://github.com/user-attachments/assets/05913af3-bea5-408f-893d-b21f522eb092" />

    
- 쿠키와 캐싱
    - 문서가 Set-Cookie헤더를 제외하고 캐시를 해도 될 경우라면 그 문서에 명시적으로 `Cache-Control: no-cache="Set-Cookie"`를 기술해서 명확히 표시
    - 캐시를 해도 되는 문서에 `Cache-Control: public`을 사용한다.

# 12장 기본 인증

## 12.1 인증

- HTTP의 인증 요구 / 응답 프레임워크
    - 웹 에플리케이션이 HTTP 요청 메시지를 받으면, 서버는 요청을 처리하는 대신에 현재 사용자가 누구인지를 알 수 있게 비밀번호 같이 개인 정보를 요구하는 '인증 요구'로 응답할 수 있음
    - 사용자가 다시 요청을 보낼 때는 인증 정보를 첨부해야함. 인증정보가 맞지 않으면 서버는 클라이언트에 다시 인증요구를 보내거나 에러
- 인증 프로토콜과 헤더
    - HTTP에는 기본 인증과 다이제스트 인증이 존재 (다이제스트는 13장)
    - 기본 인증
        
        
        | 단계 | 헤더 | 설명 | 메서드/상태 |
        | --- | --- | --- | --- |
        | 요청 |  | 첫 번째 요청에는 인증 정보가 없다 | GET |
        | 인증요구 | WWW-Authenticate GET | 서버는 사용자에게 사용자 이름과 비밀번호를 제공하라는 의미로 401 상태 정보와 함께 요청을 반려한다. | 401 Unauthorized |
        | 인증 | Authorization | 클라이언트는 인증 알고리즘과 사용자 이름,비밀번호를 기술한 Authorization 헤더를 보낸다. | GET |
        | 성공 | Authentication-Info | 인증 정보가 정확하면, 서버는 문서와 함께 응답한다. | 200 OK |

## 12.2 기본 인증

- 예시
    1. 사용자가 리소스를 요청한다.
    2. 서버가 `WWW-Authenticate` 헤더와 함께 리소스를 접근하는데 필요한 비밀번호를 요구하는 `401 Authorization Required` 응답을 반환한다.
    3. 브라우저에서 401 응답을 받고 사용자 이름과 비밀번호를 입력하는 화면을 띄운다. 브라우저는 정보들을 콜론으로 이어 붙이고, `base-64`방식으로 인코딩하고, Authorization 헤더에 그 값을 담아 서버로 다시 보낸다.
    4. 서버는 사용자 이름과 비밀번호를 디코딩하고, 그 값이 정확한지 확인하고, 문제 없으면 HTTP 200 OK 메시지와 함께 요청받았던 문서를 보낸다.
- Base-64 사용자 이름/비밀번호 인코딩
    - HTTP 기본 인증은 사용자 이름과 비밀번호를 클론으로 이어서 합치고, base-64인 코딩 메서드를 사용해 인코딩함
    - base-64 인코딩은 8비트 바이트로 이루어져 있는 시퀀스를 6비트 덩어리의 시퀀스로 변환
    - base-64 인코딩은 국제 문제나 HTTP 헤더에서 사용할 수 없는 문자를 보내야 할 때 유용
- 프락시 인증
    - 중개 프락시 서버를 통해 인증 가능
    - 프락시 서버에서 접근 정책을 중앙 관리 할 수 있기 때문에, 회사 리소스 전체에 대해 통합적인 접근 제어를 하기 위해서 프락시 서버를 사용하면 좋음

## 12.3 기본 인증의 보안 결함

- 기본인증은 사용자 이름과 비밀번호를 쉽게 디코딩할 수 있는 형식으로 네트워크에 전송하며 이는 누구나 디코딩할 수 있도록 쉽다.
- 보안 비밀번호가 디코딩하기에 더 복잡한 방식으로 인코딩 되었더라도 공격 예방에 도움되지 않는다.
- 중요 정보가 아니더라도 일반 사용자가 보기에는 위험해 보인다.
- 메시지의 인증 헤더를 건드리지 않지만, 그 외 다른 부분을 수정해서 트랜잭션의 본래 의도를 바꿔버리는 프락시가 개입하는 경우, 기본 인증의 정상작동을 보장하지 않는다.
- 가짜 서버의 위장에 취약하다.
