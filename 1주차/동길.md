### 요약

```
결국 웹은 어떤 서비스를 구성한 축이기에 앞서 정보를 전달하기 위한 발판.
HTTP는 이 때 정보 전달을 어떻게 효과적으로 할 것인가? 에 대한 고민의 결과물
여기서 나오는 정보들은 클라이언트 어플리케이션(브라우저)과 서버사이의 내용이 아니라면 실제로 구현되지 않는 부분들도 많아서, 그런 부분들을 잘 구별해서 읽으면 정보 습득에 도움이 될 수 있을 것 같다.
버전 정보에 대한 관리, 구버전 호환성은 어디에서나 존재함. HTTP도 예외가 아니다.
```

# HTTP 개관

신뢰성 있는 데이터 전송 프로토콜인 TCP를 사용하기에 손상되거나 꼬이지 않음

### 웹 클라이언트와 서버

서버는 클라이언트에게 응답을 보냄
클라이언트는 서버에 요청을 보냄

요청을 보내면 서버는 해당 리소스가 있는지 찾고,있다면 타입, 길이를 HTTP 응답에 실어서 클라이언트에게 보냄

### 리소스

단순 리소스 : 웹서버 파일 시스템의 정적파일
리소스는 반드시 정적파일일 필요가 없음

### 미디어타입(Content-Type)

수천가지 데이터타입을 다루기에 HTTP는 웹에서 전송되는 객체 각각에 MIME 타입을 추가한다.
(Multipurpose Internaet Mail Extensions)
=> 원래의 밈타입은 각기 다른 전자메일 시스템 사이에서메시지가 오갈때 겪는 문제점을 해결하기 위해 설계되었다.

웹서버는 모든 HTTP객체 데이터에 MIME타입을 붙임
웹브라우저는 다룰 수 있는 객체인지를 MIME타입을 통해 확인함

#### MIME Type의 구성

1. 주타입 : primary object type ex) text
2. 부타입 : specific subtype ex) html
   => text/html, image/jpeg, image/gif, video/quicktime, application/vnd.ms-powerpoint
   생각보다 더많은 실험용/특수 용도의 밈타입이 존재함

# URI

웹 서버의 리소스는 각자 이름을 갖고 있고, 클라이언트는 그것으로 데이터를 가져온다.
이 이름을 통합 자원 식별자 (Uniform Resource Identifier)라고한다.

### 종류

1. URL
2. URN

### URL

uniform resource locator -> 통합 자원 지시자
리소스 식별자의 가장 흔한 형태
특정 서버의 한 리소스에 대한 구체적인 위치를 서술

프로토콜(스킴)+ 주소 + 리소스형태

### URN

Uniform Resource Name
콘텐츠를 이루는 한 리소스에 대해 그 리소스의 위치에 영향받지 않는 유일무이한 이름 역할을 함
아직 실험중인 상태고, 아직 널리 채택되지 않음

# 트랜잭션

트랜잭션은 클라이언트의 `요청` , 서버의 `응답` 으로 구성

### 메서드

모든 HTTP요청 메시지는 하나의 메서드를 갖는다.
서버에 어떤 동작이 취해져야하는지를 말해준다.

1. GET : 서버에서 클라로 지정한 리소스를 보내라
2. PUT : 클라에서 서버로 보낸 데이터를 지정한 이름의 리소스로 저장하라
3. DELETE: 리소스를 서버에서 삭제하라
4. POST : 클라이언트 데이터를 서버. ㅔ이트웨이 어플리케이션으로 보내라
5. HEAD: 지정한 리소스에 대한 응답에서, HTTP 헤더 부분만 보내라

## 웹페이지의 구성

html로 뼈대를 긁어오고, 나머지 리소스를 다른 서버등 여러 곳에서 가져옴
따라서 웹페이지는 리소스의 모음

## 메시지

### 메시지 구성

1. 시작줄
2. 헤더
3. 본문

### 시작줄

요청이라면 무엇을 해야하는지
응답이라면 무슨 일이 일어났는지를 나타냄

### 헤더

시작줄 다음에는 0개 이상의 헤더필드가 이어짐
:로 구분된 key-value로 구성
헤더는 . 빈줄로 끝남

### 본문

본문은 어떤 종류의 데이터든 들어갈 수 있음
요청은 서버로 데이터를 실어 보냄. 응답은 데이터를 반호나함
본문은 임의의 이진 데이터를 포함한다.(이미지, 비디오, 오디오트랙, 응용 소프트웨어)

## HTTP 프로토콜 버전

### 1.0

처음 널리쓰이기 시작한 HTTP버전
버전 번호, 헤더, 추가메서드, 멀티미디어 객체를 추가해서 폼이 구현됨

### HTTP 1.0+

keep-alive 커넥션,가상 호스팅 지원, 프록시 연결지원

### HTTP 1.1

현재의 HTTP버전

## 캐시

웹 캐시, 캐시 프록시는 자주 찾아지는 사본을 저장해두는 HTTP 프록시 서버임
클라이언트는 멀리 떨어진 웹서버보다 근처의 캐시에서 훨씬 . 더빨리 문서를 다운 받을 수 있음

## 게이트웨이

다른 서버들의 중개자로 동작하는 서버
HTTP트래픽을 다른 프로토콜로 변환하기위해서 주로 사용됨
게이트웨이는 스스로가 리소스를 가진 서버처럼 요청을 다루기때문에 클라는 게이트웨이와 통신하는 것을 알 수 없다.

# URL과 리소스

### URL의 구성

URL은 어떤 정보를 얻기위한 총제적인 기술적 문법
스킴 + 호스트 + 경로
-> 어떻게 + 어디에 + 무엇을

### URL문법

`<스킴>://<사용자이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프레그먼트>`

`스킴` : 리소스를 가져오기위한 프로토콜, 대소문자를 가리지 않음
`사용자 이름`: 기본값 annoymous,
`비밀번호`: 사용자의 비밀번호,
`호스트`: 호스트명이나 IP주소
`포트` : 서버가 열어둔 포트번호
`경로` : 이전 컴포넌트와 빗금으로 구분되어 있으며, 서버 내 리소스가 서버 어디에 있는지 가리킴
`파라미터` : 특정 스킴에서 파라ㅏ미터 기술
`질의`: 파라미터
`프래그먼트` : 리소스 조각이나 일부를 가리키는 이름

## 단축 URL

상대 URL : 리소스 내부 리로스를 간결하게 기술 가능

### 상대 URL

url을 짧게 표기하는 방식
기저 URL을 통해 리소스를 찾는 방식
상대 URL은 프래그먼트이거나 URL의 일부임

상대 URL변환

### 기저 URL찾기

    - 리소스에서 명시적으로 제공하는 경우 -> HTML문서에서 \<BASE>를 쓰면 바꿀 . 수있음
    - 리소스를 포함하고있는 기저 URL -> 기저URL이 명시되지 않은 경우, 해당 리소스의 URL을 기저 URL로 쓸  수 있음
    - 기저URL이 없는 경우
    	절대 URL로 이뤄짐, 불완전하거나 깨진 URL일수도 있음

### 인코딩 체계

안전하지 않은 문자들을 표현할 수 있는 인코딩 방식이 고안됨
몇 문자들은 URL 내에서 특별한 의미로 예야고디어있음
![](https://i.imgur.com/88N1RHz.png)

# HTTP 메세지

### 인바운드와 아웃바운드

트랜잭션 방향을 표현하기 위해 사용함
메시지가 원 서버 방향으로 향하는 것 -> 인바운드로 이동
모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것 -> 아웃바운드로 이동

`인바운드` : 서버방향
`아웃바운드` : 클라이언트 방향

### 다운스트림 메시지

모든 HTTP메시지는 강물과 같이 아래로 흐른다.
모든 메시지는 다운스트림으로 흐른다.
메일 발송자는 수신자의 업스트림이다.

=> 방향에 따라 업스트림과 다운스트림이 바뀐다.

## 메시지 문법

### 요청

```
<메서드> <요청 URL> <버전>
<헤더>

<엔터티 본문>
```

버전 : 이 메시지에서 사용중인 HTTP의 버전
`HTTP/메이저.마이너`로 나타냄

### 응답

```
<버전><상태 코드><사유 구절>
<헤더>

<엔터티 본문>
```

### 헤더

HTTP/1.1과 같은 몇몇 버전의 HTTP에서는 요청이나 응답에 특정 헤더가 포함되어야 유효한 것으로 침

### 엔터티 본문

내용이 없어도 HTTP 헤더의 집합은 반드시 빈줄로 끝나야함

### 시작줄

#### 메서드에 관해

1. GET : 서버에서 어떤 문서르 ㄹ가져옴
2. HEAD: 서버에서 어떤 문서에 대해 헤더만 가져옴
3. POST: 서버가 처리해야할 데이터를 보냄
4. PUT : 서버에 요청 메시지의 본문을 저장함
5. TRACE : 메시지가 프록시를 거쳐 서버에 도달하는 과정을 추적함
6. OPTIONS : 서버가 어떤 메서드를 수행할 수 있는지를 확인한다.
7. DELETE : 서버에서 문서를 제거

### 상태코드

100번대 : 정보
200번대 : 성공
300번대 : 리다이렉션
400번대 : 클라이언트 에러
500번대 : 서버 에러

### 흔히 쓰는 헤더

1. Date : 서버가 응답을 만들어 낸 시각
2. Content-Length : 본문 데이터의 바이트 수
3. Content-Type: 본문의 MIME 타입
4. Accept : 클라이언트에서 받아들일 수 있는 데이터

## 메서드

### 안전한 메서드

HTTP에서 정의된 거임
GET, HEAD는 안전함
둘은 요청의 결과로 서버에 어떤 영향을 미치지 않는다고 정의한다. (실제 구현은 다를 수도 있다. 개발자가 하기나름)
이 목적은 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 브라우저를 만들 수 있도록 하는 것에 있음

GET -> 실제 내용을 가져옴
HEAD -> 리소스를 안 가져오고도 리소스에 대한 정보를 알아낼 수 있음

### PUT

1. 요청 본문에 대해 해당 이름을 가진 문서가 없다면 그 문서를 생성
2. 이미 해당 리소스가 있다면 본문을 사용해서 교체
   => 멱등성이 보장됨

### POST

서버에 입력데이터를 전송하기위해 설계됨
여러번 같은 요청을 하면 중복데이터가 생성될 수 있음
=> 멱등성이 보장되지 않음

### TRACE

진단용이며, 요청에 본문을 보낼 수 없음
요청에 본문을 담아서 보내면, 서버는 받은 요청을 그대로 보냄

### OPTIONS

웹서버에게 여러가지 종류의 지원 범위에 대해 물어볼 수 있음
서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있음

### DELETE

삭제, 하지만 클라이언트는 삭제가 수행되는 것을 보장하지 못함
명세상 클라에게 알리지 않고 요청무시가 가능함

## 상태코드

### 100번대

정보성 상태코드
100 : Continue , 일부가 받아들여졌으며, 클라는 나머지 정보를 이어서 보내라. -> 본문 전송 전에 확인하기위해서 보통 사용함
101 : Switching Protocol, 클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음

### 200번대

200 : OK
201 : Created
202 : Accepted, 받긴했는데, 동작은 안했음
203 : Non-Authoritative Information, 엔터티 헤더에 들어있는 정보가 원래 서버가 아닌 리소스의 사본에서 왔다.
204 : No Content, 새문서로 이동시키지 않고, 갱신시키고자 할때 사용
205 : Reset Content, 폼 내부의 모든 값을 비워라
206 : Partial COntent, 부분 혹은 범위 요청이 성공했다. 응답헤더에 Date와 Content-Rage를 꼭 포함해야함, Etag와 Content-Location중 하나의 헤더도 반드시 포함해야함

### 300번대

300 : Multiple Choices, 동시에 여러 리소스를 가리키는 URL을 요청한 경우 해당 리스트와 함께 반환
301: Moved Permanentrly, 요청한 URL이 옮겨졌을때
302 : Found 301과 같음.

### 400번대

400 : Bad Request
401 : Unauthorized
403 : Forbidden, 금지되었으나, 이유를 알리고 싶지 않다.
404 : Not Found
405 : Method Not Allowed , 해당 URL에 대해 지원하지 않는 메서드로 요청시

### 500번대

500 : 서버 에러
501: Not Implemented 클라가 서버의 능력을 넘은 요청시
502: Bad Gateway 프록시나 게이트웨이처럼 동작하는 서버가 요청 응답 연쇄에 있는 다음 링크로 부터 가짜 응답에 맞닥드렸을때 사용
503 : Service Unavailable

## 헤더

다섯 종류의 헤더로 구분

### 1. 일반 헤더

클라와 서버 양쪽 모두 사용하는 헤더

1. Connection: 클라이언트와 서버가 연결에 대한 옵션을 정할 수 있게 함
2. Date: 메시지가 언제 만들어졌는가
3. MIME-Version: 발송자가 사용한 MIME의 버전
4. Trailer chunked transfer : 인코딩된 메시지의 끝부분에 위치한 헤더들의 목록 나열
5. Transfer-Encoding : 메시지에 어떤 인코딩이 적용되었는지
6. Upgrade : 발송자가 업그레이드하길 원하는 새 버전이나 프로토콜을 알려줌
7. Via : 프록시나 게이트웨이를 거쳐왔는지 보여줌

#### 일반 캐시 헤더

HTTP/1.0에서는 최초의 캐시 헤더가 도입되었다.

1. Cache-Control : 메시지와 함께 캐시 지시자를 전달하기위해 사용
2. Pragma : 메시지와 함께 지시자를 전달하는 또 다른 방법 (요청헤더이다., deprecated될 예정)

### 2. 요청헤더

요청 메시지를 위한 헤더.
요청메시지에서만 의미를 갖는다.

1. Client-IP : 클라이언트가 실행된 PC의 IP
2. From: 메일주소
3. Host: 요청 대상 서버의 호스트명과 포트
4. Referrer : 현재 URI가 들어있었던 문서의 URI를 제공한다.
5. UA-Color: 기기 디스플레이의 색상 능력에 대한 정보 제공
6. UA-CPU : 클라이언트 CPU종류, 제조사
7. UA-Disp: 클라이언트의 디스플레이 능력에 대한 정보 제공
8. UA-OS : 클라이언트 OS정보
9. UA-Pixels : 기기 디스플레이에대한 픽셀 정보 제공
10. User-Agent: 요청 보낸 앱의 이름을 서버에게 알려줌

#### Accept 관련 헤더

클라이언트가 서버에게 자신의 선호와 능력을 알려줌
=> 불필요한 정보 전송을 막을 수 있어서 성능에 좋을지도?

1. Accept: 보내도 되는 미디어 종류를 알려줌
2. Accept-Charset : 보내도 되는 문자 집합을 말해줌
3. Accept-Encoding: 서버에게 서버가 보내도 되는 인코딩을 알려줌
4. Accept-Language: 서버에게 보내도 되는 언어를 알려줌
5. TE: 서버가 보내도 되는 확장 전송 코딩을 알려줌

#### 조건부 요청 헤더

서버에게 요청 응답 전에 해당 조건이 참인지 확인하라고 할 수 있음

1. Except: 요청에 필요한 서버의 행동을 열거
2. If-Match: 엔터티 태그가 주어진 태그와 일치하는 경우에만 문서를 가져옴
3. If-Modified-Since : 주어진 날짜 이후 리소스가 변경되지 않았다면, 요청을 제한
4. If-None-Match: 문서의 엔터티 태그가 주어진 엔터티 태그와 일치하지 않는 경우에만 문서를 가져옴
5. If-Range: 특정 범위에 대한 요청
6. If-Unmodified-Since : 주어진 날짜 이후에 리소스가 변경되었다면 요청을 제한함
7. Range: 서버가 범위요청을 지원한다면, 리소스에 대한 특정 범위를 요청

#### 요청 보안 헤더

1. Authorization: 인증 자체에 대한 정보
2. Cookie: 서버에 토큰 전달할때 사용
3. Cookie2: 클라이언트의 쿠키 버전 정보

#### 프록시 요청 헤더

1. Max-Forwards: 요청이 원서버로 향하면서 다른 프록시나 게이트웨이로 전달될 수 있는 최대 횟수
2. Proxy-Authorization: Authorization이랑 같은데 proxy서버에 대한 인증
3. Proxy-Connection: connection과 같으나 proxy에서 사용

### 3. 응답헤더

서버의 응답시에 클라이언트에게 정보를 제공하기 위한 헤더

1. Age : 응답이 얼마나 오래되었는가 -> 응답이 중개자를 통해 왔다는 것을 암시
2. Public: 서버가 특정 리소스에 대해 지원하는 요청 메서드의 목록
3. Retry-After: 현재 리소스가 사용 불가능한 상태일때, 가능해지는 날짜 혹은 시간
4. Server : 서버 어플리케이션의 이름과 버전
5. Title: HTML문서에서 주어진 것과 같은 제목
6. Warning: 사용 구절에 있는 것보다 더 자세한 경고메시지

#### 협상헤더

협상 가능한 리소스에 대한 정보 운반 헤더

1. Accpet-Ranges: 서버가 자원에 대해 받아들일 수 있는 범위의 형태
2. Vary: 서버가 확인해보아야하고 그렇기 떄문에 응답에 영향을 줄 수 있는 헤더의 목록

#### 응답 보안헤더

1. Proxy-Authenticate : 프록시에서 클라이언트로 보낸 인증 요구의 목록
2. Set-Cookie: 쿠키 설정
3. Set-Cookie2: RFC 2965로 정의된 쿠키
4. WWW-Authenticate: 서버에서 클라이언트로 보낸 인증 요구의 목록

### 4. 엔터티 헤더

엔터티 본문에 대한 헤더
ex) Content-Type

1. Allow: 이 엔터티에 대해 수행될 수 있는 요청 메서드를 나열
2. Location: 클라이언트에게 엔터티가 실제로 어디에 위치하고 있는지 말해줌

#### 콘텐츠 헤더

엔터티 콘텐츠에 대한 구체적이 ㄴ정보를 제공

1. Content-Base : 기조 URL
2. Content-Encoding: 적용된 인코딩
3. Content-Language: 이해를 위해 가장 적절한 자연어
4. Content-Length: 본문 길이나 크기 (byte)
5. Content-Location: 실제 위치
6. Content-MD5 : 본문의 MD5체크섬
7. Content-Range: 전체 리소스에서 이 엔터티가 해당하는 범위를 바이트단위로 표현
8. Content-Type: 어떤 종류의 객체인지

#### 엔터티 캐싱 헤더

언제 어떻게 캐시가 되어야 하는지 지시자를 제공

1. Etag: 이 엔터티에 대한 엔터티 태그
2. Expires : 엔터티가 더이상 유효하지 않아 원본을 다시 받아와야 하는 일시
3. Last-Modified: 가장 최근 이 엔터티가 변경된 일시

### 5. 확장 헤더

어플리케이션 개발자들에 의해 만들어졌지만, 승인된 HTTP명세에는 추가되지 않은 비표준 헤더
