왜 HTTP를 이해하는게 중요한가?

WWW를 지탱하는 중요한 기술은 HTML + HTTP

HTTP는 웹의 구성요소들이 서로 대화할 때 사용하는 프로토콜 

→ HTTP를 이해한다 = 웹이 어떻게 동작한다는지 이해하는 것

**본인 1차 목표: “**주소창에 google.com을 입력하면 일어나는 일**” 
→ 이 질문에 A-Z까지 전문적으로 상세하게 잘 설명하기**

### 1부 가이드

1부는 HTTP의 핵심 기술과 웹의 기초에 대해 다룸

1. HTTP 개관: HTTP에 대해 개략적으로 살펴보기
2. URL과 리소스: Uniform Resource Locator, URL의 포맷과 인터넷상에서 URL이 가리키는 리소스의 다양한 형식에 대해 상세히 다룬다. 그리고 URL에서 더 진화한 지시자인 URN에 대해 내용도 다룬다.
3. HTTP 메시지: HTTP 메시지가 어떻게 웹 콘텐츠를 전송하는지 알아보기
4. 커넥션 관리: HTTP 커넥션 관리에 대한 흔한 오해와 잘못 작성된 규칙 및 동작 설명

# 1장 HTTP 개관

## 1.1 HTTP: 인터넷의 멀티미디어 배달부

- HTTP는 전 세계의 웹 서버로부터 대량의 정보를 사람들의 PC에 설치된 웹브라우저로 옮겨준다.
- HTTP는 **신뢰성 있는 데이터 전송 프로토콜(TCP)**을 사용하기 때문에, 전송 중 손상되거나 꼬이지 않음을 보장 → 개발자는 인터넷의 결함, 약점에 대한 걱정 없이 애플리케이션 기능 구현에 집중 가능

## 1.2 웹 클라이언트와 서버

- 웹 콘텐츠는 웹 서버에 존재
- **웹 서버**는 HTTP 프로토콜로 의사소통 하기 때문에 **HTTP 서버**로 일컬어짐.
    - 인터넷 데이터를 저장하고
    - HTTP 클라이언트(e.g. 웹브라우저)는 HTTP 요청
    - HTTP 서버는 요청받은 데이터를 HTTP응답

## 1.3 리소스

- 웹 서버는 웹 리소스를 관리하고 제공
- 웹 리소스는 웹 콘텐츠의 원천
    - 웹 서버 파일 시스템의 **정적** 파일
        - e.g. 텍스트, HTML, Word, JPEG, AVI …
    - 리소스는 요청에 따라 콘텐츠를 생산하는 **동적 콘텐츠 리소스**가 될 수 있음 (누구인지, 어떤 정보 요청인지, 몇시인지 등에 따라)
        - e.g. 웹 캠, 주식거래, 부동산, 전자상거래 등

어떤 종류의 콘텐츠 소스도 리소스가 될 수 있다.

### 1.3.1 미디어 타입

인터넷은 수천가지의 데이터 타입을 다루기에, HTTP는 웹에서 전송되는 객체 각각에 **MINE** 타입이라는 데이터 포맷 라벨을 붙인다.

- **Multipurpose Internet Mail Extensions, MIME 마임**
    - 원래 각기 다른 전자 메일 시스템 사이에 메시지가 오갈 때 겪는 문제점을 해결하기 위해 설계
        - 원래 아스키 문자, 즉 텍스트만 전송 가능한 SMTP를 확장해서 다양한 데이터 형식(한글, 이미지, 동영상..)을 전송 가능하게 한 것
    - 헤더 + 바디 인코딩 규칙을 추가하는 방식으로 동작
        - MIME 타입: slash로 구분된 primary object type과 specific subtype으로 이루어진 문자열 라벨 (*전체 목록은 부록 D 참고)
        
        ```
        Content-Type: text/plain; charset=UTF-8 
        -> 본문이 UTF-8 인코딩된 일반 텍스트
        
        Content-Type: image/png
        Content-Transfer-Encoding: base64
        -> 본문이 PNG 이미지인데, 이메일에 맞게 base64로 인코딩되었음
        
        Content-Type: application/json
        ```
        
    - 잘 동작해서 HTTP에서도 멀티미디어 콘텐츠 기술 및 라벨링을 위해 채택
- 웹서버는 모든 HTTP 객체에 MIME 타입을 붙인다.
    
    why? 웹브라우저(클라이언트)는 서버로부터 객체를 돌려받을 때, **다룰 수 있는 객체인지 MIME 타입을 통해 확인**, 웹브라우저는 잘알려진 객체 타입 수백 가지를 다룰 수 있음
    

### 1.3.2 URI

- **Uniform Resource Identifier, URI**
    - 서버 리소스 이름, **정보 리소스를 고유하게 식별하고 위치를 지정**할 수 있다.
- URI가 HTTP 프로토콜에서 해석되는 과정
    - `http://www.joes-hardware.com/specials/saw-blade.gif`
        1. `http` : HTTP 프로토콜을 사용하다
        2. [`www.joes-hardware.com`](http://www.joes-hardware.com) : www.joes-hardware.com으로 이동하라
        3. `/specials/saw-blade.gif` : /specials/saw-blade.gif라고 불리는 리소스를 가져와라
    - URI는 **URL과 URN 두 종류의 자원 식별자**가 있다.

### 1.3.3 URL

- Uniform Resource **Locator, URL**
    - 특정 서버의 한 리소스에 대해 **구체적인 위치와 접근방법을** 서술
    - 오늘날 대부분의 URI는 URL
    - https://developer.mozilla.org/ko/docs/Learn_web_development/Howto/Web_mechanics/What_is_a_URL
    
    ![image.png](attachment:b4d983e4-4467-4aed-9e5e-3e7d7c3e5dd2:image.png)
    
    - Scheme: 리소스에 접근하기 위해 사용되는 프로토콜
    - Authority: 도메인 이름과 포트가 포함. `://` 로 scheme과 구분
    - 웹서버의 리소스 경로
    - 매개변수: `&`로 구분된 키/값 쌍 목록
    - 앵커: 리소스 내부의 책갈피 역할, 브라우저가 앵커가 정의된 지점으로 스크롤. `#`뒤의 부분은 **요청과 함께 서버로 전송되지 않음**

### 1.3.4 URN

- Uniform Resource **Name**, URN
    - 콘텐츠를 이루는 한 리소스에 대해, 그 리소스의 **위치에 영향을 받지 않는 유일무이한 이름** 역할 → 위치 독립적, 리소스를 옮기더라도 문제없이 작동. 여러 종류의 네트워크 접속 프로토콜로 접근해도 문제 없음
    - `urn:` scheme 사용
        
        ```
        urn:isbn:0451450523
        	•	urn: → URN임을 나타냄
        	•	isbn: → 네임스페이스(책의 ISBN 번호 체계)
        	•	0451450523 → 실제 책 번호
        	책이 어떤 출판사 서버에 있든 상관없이, 그 책 자체를 지칭
        ```
        
    - 현재 실험 중인 상태로 널리 채택 X. 리소스 위치를 분석하기 위한 인프라 지원이 필요한데 해당 인프라가 부재해서 늦춰지는 중.
    

통상적인 관례에 따라 URI와 URL을 같은 의미로 사용할 것

## 1.4 트랜잭션

**HTTP 트랜잭션**은 **요청 명령**과 **응답 결과**로 구성

- HTTP 요청 메시지는 명령과 URI를 포함
- HTTP 응답 메시지는 트랜잭션의 결과를 포함

이 상호작용은 **HTTP 메시지**라는 정형화된 데이터 덩어리를 이용해 이뤄짐

### 1.4.1 메서드

- 모든 HTTP **요청** 메시지는 한 개의 **메서드**를 갖는다.
- 메서드는 서버에게 어떤 동작이 취해져야 하는지 말해준다. (3장에서 세부적으로 다룰 예정)

### 1.4.2 상태 코드

- 모든 HTTP **응답** 메시지는 **상태 코드**와 함께 반환된다.
- 클라이언트에게 요청이 성공했는지 아니면 추가 조치가 필요한지 알려주는 세 자리 숫자
- 숫자 상태 코드에 텍스트로 된 reason phrase도 함께 보낸다. 단순 설명을 위해 포함된다. 실제 응답 처리에서는 숫자 코드 사용.

### 1.4.3 웹페이지는 여러 객체로 이루어질 수 있다

- 애플리케이션은 보통 하나의 작업을 수행하기 위해 여러 HTTP 트랜잭션을 수행한다
e.g. HTML, script, image, … 웹페이지는 보통 하나의 리소스가 아닌 **리소스의 모임**

## 1.5 메시지

- **HTTP 메시지**는 **단순한 줄 단위의 문자열**. 이진 형식이 아닌 **일반 텍스트**이기 때문에 사람이 읽고 쓰기 쉽다.
- HTTP 메시지는 다음의 세 부분으로 이뤄진다.
    - 시작줄
        - 요청이라면 무엇을 해야하는지, 응답이라면 무슨 일이 일어났는지 표현
    - 헤더
        - 시작줄 다음에는 0개 이상의 헤더필드가 이어짐
        - 각 헤더 필드는 구문분석을 위해 `:`으로 구분, 이름-값
        - 헤더는 빈 줄로 끝남
    - 본문
        - 헤더의 빈 줄 다음에는 어떤 종류의 데이터든 들어갈 수 있는 메시지 본문이 필요에 따라 올 수 있음
        - 본문은 텍스트뿐만 아니라 임의의 이진 데이터를 포함 가능(이미지, 비디오, 오디오 트랙, 응용소프트웨어)

## 1.6 TCP 커넥션

### 1.6.1 TCP/IP

- HTTP는 **Application Layer** → 하위 계층의 작업의 세부사항에 대해서 신경쓰지 않음. 대신 신뢰성 있는 인터넷 전송 프로토콜 **TCP/IP**에게 맡김
- TCP가 제공하는 것 (Transport Layer)
    - 오류 없는 데이터 전송
    - 순서에 맞는 전달 (데이터는 언제나 보낸 순서대로 도착)
    - 조각나지 않는 데이터스트림 (언제든 어떤 크기로든 보낼 수 있음)
    
    ![image.png](attachment:ed918cf1-35ef-4cd6-934d-a4e67beca58c:image.png)
    

### 1.6.2 접속, IP 주소 그리고 포트번호

- HTTP 트랜잭션을 위해서는 **IP주소와 포트번호**를 사용해 클라이언트와 서버 사이에 **TCP/IP 커넥션** 필요
    - 서버 컴퓨터에 대한 IP주소와 그 서버에서 실행 중인 프로그램이 사용 중인 포트번호 → URL 확인
    - URL 예시
    
    ```
    http://207.200.83.29:80/index.html
    http://www.netscape.com:80/index.html -> 도메인 네임 사용.
    http://www.netscape.com/index.html -> 포트 번호가 빠진 경우 기본값 80이라 가정
    ```
    
- HTTP를 통해 HTML 리소스가 사용자에게 보여지는 과정
    1. 웹브라우저는 서버의 URL에서 호스트명을 추출
    2. 웹브라우저는 서버의 호스트명을 IP로 변환 (DNS,, iterative or recursive query)
    3. 웹브라우저는 URL에서 포트번호(있다면)를 추출한다.
    4. 웹브라우저는 웹서버와 TCP커넥션을 맺는다 (3-way handshake)
    5. 웹브라우저는 서버에 HTTP 요청을 보낸다
    6. 서버는 웹브라우저에 HTTP 응답을 돌려준다
    7. 커넥션이 닫히면(4-way handshake), 웹브라우저는 문서를 보여준다.

### 1.6.3 telnet을 이용한 실제 예제

- telnet, TELecommunication NETwork
    - 원격지 컴퓨터에 접속해서 터미널(명령줄)을 사용하는 프로토콜, 요즘에 SSH로 하는것
    - 단순 TCP 연결은 가능하지만 요즘은 차단/비권장.
    
    ```bash
    telnet www.google.com 80
    Trying 142.250.206.196...
    Connected to www.google.com.
    Escape character is '^]'.
    GET / HTTP/1.1
    Host: www.google.com
    
    HTTP/1.1 200 OK
    Date: Mon, 15 Sep 2025 12:00:34 GMT
    Expires: -1
    Cache-Control: private, max-age=0
    Content-Type: text/html; charset=ISO-8859-1
    ...
    ```
    
    - telnet 명령어로 구글 서버 80번 포트에 TCP 연결
    - HTTP 요청 입력 (헤더 마지막 빈줄까지 넣어야 요청 완료)
    - HTTP 응답으로 HTML 본문 받음
- 참고) netcat
    - 범용 네트워크 도구. TCP/UDP, 서버/클라이언트 모드 다 지원. HTTP, SMTP 등 여러 프로토콜 테스트에 자주 사용됨.

## 1.7 프로토콜 버전

- HTTP/0.9 (1991)
    - 가장 초창기 버전으로 간단한 HTML 객체를 받아오기 위해 만들어짐
    - GET 메서드만 지원, 멀티미디어 콘텐츠에 대한 MIME 타입, HTTP 헤더, 버전 번호는 미지원
- HTTP/1.0 (1996, RFC 1945)
    - 정식으로 표준화된 첫 HTTP 버전
    - 버전번호, HTTP 헤더, 추가 메서드, 멀티미디어 객체 처리 추가
    - 한계: 커넥션을 요청마다 새로 맺음 → 비효율적 (매번 TCP 3-way handshake)
- HTTP/1.0+ (비공식 확장)
    - 1.0의 한계를 보완하기 위해 브라우저/서버 업체들이 만든 확장 기능
    - **keep-alive,** 가상 호스팅, 프락시 연결 지원 등 공식은 아니지만 사실상의 표준으로 추가됨
- HTTP/1.1
    - 가장 널리 쓰이는 버전, 지금도 대부분 사용
- **HTTP/2.0 ← 네이버 cs**
    - HTTP/1.1 성능 문제를 개선하기 위해 구글의 SPDY 프로토콜을 기반으로 설계가 진행 중인 프로토콜
    - 10장에서 진행

## 1.8 웹의 구성요소

### 1.8.1 프락시 Proxy

- 클라이언트와 서버 사이에 위치한 HTTP 중재자, 사이에서 트래픽 전달
- 클라이언트의 모든 HTTP 요청을 받아 서버에 전달 (대게 요청을 수정한 뒤에)
- 주로 보안을 위해 사용. 요청과 응답을 필터링
- e.g. 회사에서 다운 받을 때 바이러스 검출, 성인 콘텐츠 차단 (6장에서)

### 1.8.2  캐시

- 웹캐시와 캐시프락시. 자신을 거쳐가는 문서들 중 자주 찾는 것의 사본을 저장해두는 특별한 종류의 HTTP 프락시 서버. (7장)

### 1.8.3 게이트웨이

- 프록시의 특수 형태
- 클라이언트 입장에서는 그냥 “서버”처럼 보이지만, 실제로는 **다른 서버/프로토콜로 연결을 대신 처리**해주는 중개자 (8장)
- **프로토콜 변환**을 주로 담당
    - e.g. HTTP → FTP, HTTP → SMTP
        - 클라이언트는 전혀 모른 채 HTTP로만 요청
    - e.g. AWS API Gateway
        - 클라이언트는 API Gateway를 진짜 서버처럼 호출. but Gateway는 내부적으로 요청을 다른 서비스로 라우팅/변환 → 람다 함수 실행, DynamoDB, S3, 기존 엔드포인트…

### 1.8.4 터널

- 단순히 HTTP 통신을 전달하기만 하는 특별한 프락시
- 두 커넥션 사이에서 raw 데이터를 열어보지 않고 그대로 전달해주는 HTTP 어플리케이션
- 주로 비 HTTP 데이터를 하나 이상의 HTTP 연결을 통해 그대로 전송해주기 위해 사용
- e.g. HTTP/SSL 터널: 암호화된 SSL 트래픽을 HTTP 커넥션으로 전송 → 웹트래픽만 허용하는 사내 방화벽 통과

### 1.8.5 에이전트

- 자동화된 HTTP 요청을 만드는 준지능적(semi-intelligent) 웹클라이언트
    - 즉 사람이 직접 브라우저를 켜서 클릭하지 않아도, 스스로 HTTP 요청을 보내는 프로그램
    - 준지능적: 단순히 정해진 한 번의 요청만 보내는 게 아니라, 조건·스케줄·규칙에 따라 스스로 판단하거나 반복 작업을 수행
    - e.g. 검색 엔진 크롤러(spider, bot), RSS, 자동화 스크립트, 모니터링 봇

# 2장 URL과 리소스

## 2.1 인터넷의 리소스 탐색하기

1장 리마인드…

- Uniform Resource **Locator, URL**
    - 특정 서버의 한 리소스에 대해 **구체적인 위치와 접근방법을** 서술
    - 오늘날 대부분의 URI는 URL
    - https://developer.mozilla.org/ko/docs/Learn_web_development/Howto/Web_mechanics/What_is_a_URL
    
    ![image.png](attachment:b4d983e4-4467-4aed-9e5e-3e7d7c3e5dd2:image.png)
    
    - Scheme: 리소스에 접근하기 위해 사용되는 프로토콜
    - Authority: 도메인 이름과 포트가 포함. `://` 로 scheme과 구분
    - 웹서버의 리소스 경로
    - 매개변수: `&`로 구분된 키/값 쌍 목록
    - 앵커: 리소스 내부의 책갈피 역할, 브라우저가 앵커가 정의된 지점으로 스크롤. `#`뒤의 부분은 **요청과 함께 서버로 전송되지 않음**
- 대부분의 URL은 동일하게 `스킴://서버위치/경로` 구조로 이루어짐
    
    → URL덕분에 **하나의 인터페이스**를 통해 일관된 방식으로 많은 리소스에 접근 가능! 유저는 브라우저가 그들이 리소스를 가져오는데 사용되는 프로토콜 접근 방식 몰라도됨.. 선언적이다
    

## 2.2 URL 문법

- 대부분의 URL 스킴의 문법은 일반적으로 9개 부분으로 나뉜다. (모든 컴포넌트를 갖는 것은 아니다)
    - `<스킴>://<사용자이름>:<비밀번호>@<호스트>:<포트>/<경로>;<파라미터>?<질의>#<프래그먼트>`
    
    | **컴포넌트** | **설명** | **기본값** |
    | --- | --- | --- |
    | **스킴** | 리소스를 가져오려면 어떤 프로토콜을 사용하여 서버에 접근해야 하는지 가리킴 | 없음 |
    | 사용자 이름 | 몇몇 스킴은 리소스에 접근을 하기 위해 사용자 이름을 필요로 함 | anonymous |
    | 비밀번호 | 사용자의 비밀번호를 가리키며 사용자 이름에 콜론(:)으로 이어서 기술 | <이메일 주소> |
    | **호스트** | 리소스를 호스팅하는 서버의 호스트 명이나 IP주소 | 없음 |
    | 포트 | 리소스를 호스팅하는 서버가 열어놓은 포트번호. 많은 스킴이 기본 포트를 가지고 있음. (HTTP는 80) | 스킴에 따라 다름 |
    | **경로** | 이전 컴포넌트와 `/` 으로 구분되어 있으며, 서버 내 리소스가 서버 어디 있는지를 가리킴. 경로 컴포넌트의 문법은 서버와 스킴에 따라 다름.  | 없음 |
    | 파라미터 | 특정 스킴들에서 입력 파라미터를 기술하는 용도로 사용. 파라미터는 이름/값을 쌍으로 가짐. 
    파라미터는, 다른 파라미터나 경로의 일부와 `;` 으로 구분하여 기술하며, 여러 개를 가질 수 있음 | 없음 |
    | 질의 (query) | 스킴에서 애플리케이션에 파라미터를 전달하는데 쓰임. 질의 컴포넌트를 작성하는데 쓰이는 공통 포맷은 없음. URL의 끝에 `?`로 구분 | 없음 |
    | 프래그먼트 (anchor) | 리소스의 조각이나 일부분을 가리키는 이름. URL이 특정 객체를 가리킬 경우에 프래그먼트 필드는 서버에 전달되지 않음. 이는 클라이언트에서만 사용. URL의 끝에서 `#`문자로 구분 | 없음 |

### 2.2.1 스킴: 사용할 프로토콜

- 주어진 리소스에 어떻게 접근하는지 알려주는 중요 정보
- 스킴 컴포넌트는 알파벳으로 시작해야하고 URL의 나머지 부분들과 첫 번째 `:` 문자로 구분함. 대소문자 가리지 않음 http = HTTP
- 2.5 (p.44)에 스킴 포맷 예시 나와있음.

### 2.2.2 호스트와 포트

- 호스트 컴포넌트는 접근하려고 하는 리소스를 가지고 있는 인터넷상의 호스트 장비
- 포트 컴포넌트는 서버가 열어놓은 네트워크 포트. 내부적으로 TCP 프로토콜을 사용하는 HTTP는 기본포트 80 사용

### 2.2.3 사용자 이름과 비밀번호

- 많은 서버가 데이터 접근을 허용하기 전에 사용자 이름과 비밀번호 요구
    - e.g. FTP 서버
    
    ```bash
    ftp://ftp.prep.ai.mit.edu/pub/gnu
    -> 값이 삽입되지 않은 경우 기본값, 사용자 이름: anonymous, 비밀번호는 브라우저 기본값
    ftp://anonymous@ftp.prep.ai.mit.edu/pub/gnu
    -> @로 URL로부터 사용자이름, 비밀번호 컴포넌트 분리
    ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu/pub/gnu
    -> :로 사용자이름과 비밀번호 분리
    http://joe:joespasswd@www.joes-hardware.com/sales_info.txt
    ```
    

### 2.2.4 경로

- 리소스가 서버에 어디에 있는지 알려줌
- 경로 컴포넌트는 `/` 문자를 기준으로 경로조각으로 나뉨 (UNIX 파일시스템의 파일 경로와 유사) →  각 경로조각은 자체만의 파라미터 컴포넌트를 가질 수 있음

### 2.2.5 파라미터

- 애플리케이션이 서버에 정확한 요청을 하기 위해 필요한 입력 파라미터를 받는데 사용
- 이름/값 쌍의 리스트로 URL 나머지 부분들로부터 `;`문자로 구분하여 URL에 기술
- e.g.
    - `ftp://ftp.prep.ai.mit.edu/pub/gnu;type=d`
        
        → gnu라는 경로조각은 type=d인 파라미터를 가진다
        
    - `http://example.com/hammers;sale=false/index.html;graphics=true`
        
        → hammers 경로조각은 sale=false, index.html 경로조각은 graphics=true인 파라미터를 가진다
        

### 2.2.6 질의 문자열

- 요청받을 리소스 형식의 범위를 좁히기 위해서 query를 받을 수 있음
- URL의 질의 컴포넌트는 게이트웨이를 가리키는 URL의 경로 컴포넌트와 함께 전달
    - e.g.`http://example.com/inventory-check?item=1234&color=blue`
        
        → 재고확인 게이트웨이로 질의 컴포넌트가 전달
        

### 2.2.7 프래그먼트

- 리소스의 특정 부분을 가리킬 수 있도록, URL은 리소스 내의 조각을 가리킬 수 있는 프래그먼트 컴포넌트 제공
    - e.g. `https://velog.io/@gominzip/리액트-파이버와-함께-알아보는-리액트-렌더링#리액트-파이버`
- 일반적으로 HTTP서버는 객체 일부가 아닌 전체만 다루기 때문에, **클라이언트는 서버에 프래그먼트를 전달하지 않음 →** URL 프래그먼트는 클라이언트에서만 사용됨

## 2.3 단축 URL

웹클라이언트는 몇몇 단축 URL을 인식하고 사용. 상대 URL은 리소스 안에 있는 리소스를 간결하게 기술하는데 사용할 수 있음

### 2.3.1 상대 URL

URL은 상대 URL과 절대 URL 두가지로 나뉨

- 절대 URL
    - 리소스에 접근하는데 필요한 모든 정보를 가지고 있음
- 상대 URL
    - URL을 짧게 표기하는 방식
    - e.g. `http://www.joes-hardware.com/tools.html` 경로의 HTML 파일 내부의 `href=”./hammers.html”` → 문서의 URL을 기준으로 상대경로로 해석
    - 리소스 경로에 대한 정보는 컴포넌트가 포함된 리소스의 기저(base)URL에서 알아낼 수 있음
    - 상대 URL은 프래그먼트이거나 URL 일부 → 브라우저는 상대URL과 절대URL 간에 상호변환을 할 수 있어야함
    - 문서 집합의 위치 변경해도 새로운 base에 의해서 해석될 수 있으므로 위치 변경에도 잘 동작함
- 기저 URL 가져오는 방법
    1. 리소스에서 명시적으로 제공
        1. HTML문서의 <BASE> HTML 태그
    2. 리소스를 포함하고 있는 기저 URL
        1. 기저 URL이 명시되지 않은 리소스에 포함된 경우, 해당 리소스의 URL을 기저 URL로
    3. 기저 URL이 없는 경우
        1. 보통 이런 경우는 절대 URL으로만 이루어져 있다는 뜻. but 불완전하거나 깨진 URL일 수 있음
- 상대 참조 해석하기 (상대 URL→ 절대URL 변환)
    - 상대 URL과 기저URL을 각각의 컴포넌트 조각으로 나누기 = URL 파싱 = 컴포넌트 단위 분리
    - 알고리즘
        
        ![image.png](attachment:60fe1048-f831-4926-b8f3-d74929ec709f:image.png)
        

### 2.3.2 URL 확장

어떤 브라우저들은 URL을 입력하는 동안 자동으로 URL을 확장해 도와줌

- 호스트명 확장
    - 단순한 휴리스틱만을 사용해서 입력한 호스트명을 전체 호스트명으로 확장
        - e.g. 주소창에 yahoo 입력하면 브라우저 자동으로 www, .com을 붙여서 확장
- 히스토리 확장
    - 사용자 URL 입력 시간 단축 → 과거 방문했던 URL 기록 저장

## 2.4 안전하지 않은 문자

어떤 인터넷 프로토콜을 통해서든 안전하게 전송될 수 있도록 URL을 설계

- 안전한 전송
    - 정보가 유실될 위험 없이 URL을 전송할 수 있다는 것
    - e.g. SMTP - 특정 문자를 제거할 수도 있는 전송방식 사용. 안전한 문자만 포함되도록
    - 안전한 알파벳 외의 문자도 포함하기 위해 이스케이프 기능 추가. 안전하지 않은 문자를 안전한 문자로 인코딩할 수 있게끔

### 2.4.1 URL 문자 집합

컴퓨터 시스템의 기본 문자집합은 보통 영어중심적으로 설정 US-ASCII 사용 → but 적은 수의 문자만 제공

so. 이스케이프 문자열 도입, 특정 문자나 데이터를 인코딩할 수 있도록 해 이동성과 완성도를 높임

### 2.4.2 인코딩 체계

안전하지 않은 문자들을 표현할 수 있는 인코딩 방식 고안

`%` 기호부터 시작해 ASCII 코드로 표현되는 두 개의 16진수 숫자로 이루어진 이스케이프 문자로 바꿈

- e.g. `~` → `126(0x7E)` → https://www.joes-hardwared.com/`%7E`joe

### 2.4.3 문자 제한

몇몇 문자는 URL 내에서 특별한 의미 예약되어 있음 → 본래의 목적이 아닌 다른 용도로 사용하려면, 그 전에 반드시 인코딩 필요

https://datatracker.ietf.org/doc/html/rfc3986#section-2.2

### 2.4.4 좀 더 알아보기

애플리케이션은 정해진 방식대로 구현해야함. 클라이언트 애플리케이션에서 안전하지 않거나 제한된 문자를 변환하는 것이 좋음.

입력받은 URL에서 어떤 문자를 인코딩해야 하는지 결정? ⇒ 브라우저와 같이 사용자로부터 최초로 URL을 입력받는 애플리케이션에서 하는 것이 적절

URL을 구성하는 각 컴포넌트마다 사용할 수 있거나 없는 문자들이 있을 것이고, 또 어떤 문자는 스킴에 따라서 가용성이 달라지기 때문에, 해당 문자들을 직접 입력 받는 애플리케이션이야말로 어떤 문자를 인코딩해야 하는지 결정하기에 가장 좋은 위치임.

## 2.5 스킴의 바다

책 도표 참고. 유명한 스킴 포맷 정리되어 있음

## 2.6 미래

URL은 인터넷 프로토콜 간 공유할 수 있는 일관된 작명 규칙 제공

but URL이 완벽한 것은 아님 → just 특정 시점에 어떤 것이 위치한 곳을 알려줌 ⇒ 리소스가 옮겨지면? URL 사용 불가

따라서 객체의 위치 상관없이 그 객체를 가리키는 실제 객체의 이름을 사용하기 → URN

- PURL (Persistent uniform resource locators)
    - 리소스의 실제 URL 목록을 관리하고 추적하는 리소스 위치 할당 서버를 두고, 해당 리소스를 우회적으로 제공
    - 전환을 위해서는 시간이 아직 많이 필요하다…

# 3장 HTTP 메시지

## 3.1 메시지의 흐름

HTTP 메세지는 HTTP 애플리케이션 간에 주고 받은 데이터의 블록

블록들은 메세지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작하고 다음에는 선택적으로 데이터가 올 수 있음.

메시지는 클라이언트 - 프락시 - 서버 사이를 흐름

### 3.1.1 **메세지는 원 서버 방향을 인바운드로 하여 송신한다.**

- 인바운드: 메시지가 원 서버로 향하는것
- 아웃바운드: 모든 처리가 끝난 뒤에 메세지가 사용자 에이전트로 돌아오는 것

### 3.1.2 다운스트림으로 흐르는 메시지

HTTP 메세지는 강물과 같이 흐른다, 요청 메세지나 응답 메세지나 관계없이 모든 메세지는 다운 스트림으로 흐른다.

e.g. (요청)클라이언트 - 프락시 … - 서버 / (응답) 서버 - 프락시… - 클라이언트

## 3.2 메시지의 각 부분

HTTP 메세지는 단순한, 데이터의 구조화 된 블럭

- 메세지 구성
    - 시작줄: 이 메시지가 어떤 메시인지 서술
    - 헤더블록: 메시지 속성
    - 본문: 데이터를 담고 있거나 안담고 있을 수도 있음
    
    → 각 구간은 줄바꿈 문자열 `CRLF`로 끝남
    
- 오래되거나 잘못만들어진 http 애플리케이션들 중에서는 캐리지리턴`\r`이나 개행문자`\n` 모두를 항상 전송하지는 않는것들도 있다?
    
    → HTTP는 1990년대부터 여러 회사/브라우저/서버가 제각각 구현
    
    - 어떤 애플리케이션은 **\n만 사용** (LF만)
    - 어떤 애플리케이션은 **\r만 사용** (CR만)
    - 혹은 **마지막 빈 줄에 CRLF를 빼먹는 경우**도 있었음
    
    → so 브라우저/서버는 이런 경우도 “웬만하면” 받아주도록 만들어졌음
    

### 3.2.1 메시지 문법

모든 HTTP 메세지는 `요청 메세지`, `응답 메세지` 로 분류

- 요청 메세지
    - 서버에 어떤 동작을 요구하는것
    
    ```bash
    <메서드> <요청URL> <버전>
    <헤더>
    
    <엔티티 본문>
    ```
    
    - 메서드
        - 클라이언트 측에서 서버가 리소스에 대해 수행해주길 바라는 동작 e.g. GET, HEAD…
    - 요청 URL
        - 요청 대상이 되는 리소스를 지정하는 완전한 URL 혹은 URL의 경로 구성요소
    - 버전
        - 이 메세지에서 사용중인 HTTP 버전
- 응답 메세지
    - 요청의 결과를 클라이언트에게 돌려주는것
    
    ```bash
    <버전> <상태코드> <사유 구절>
    <헤더>
    
    <엔티티 본문>
    ```
    
    - 상태코드
        - 요청 중에 무엇이 일어났는지 설명하는 세 자리 숫자
        각 코드의 첫 번째 수는 상태의 일반적인 분류(성공, 실패 , 에러 등)를 나타낸다.
    - 사유 구절
        - 숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 구문
        사유 구절은 오로지 사람에게 읽히기 위한 목적으로만 존재
    - 헤더들
        - 이름, 콜론(:), 선택적인 공백, 값 CRLF가 순서대로 나타나는 0개 이상의 헤더들, 이 헤더의 목록은 빈 줄(CRLF)로 끝나 헤더 목록의 끝과 엔티티 본문의 시작을 표시
    - 엔티티 본문
        - 엔터티 본문은 임의의 데이터 블록을 포함
        - 모든 메세지가 엔터티 본문을 포함하는것은 아니므로 떄떄로 메세지는 CRLF으로 끝나게 됨

### 3.2.2 시작줄

모든 HTTP 메세지는 시작줄로 시작한다.

- 요청줄
    - 요청 메세지의 시작줄, 혹은 요청줄에서는 서버에서 어떤 동작이 일어나야 하는지 설명해주는 **메서드**와 그 동작에 대한 대상을 지칭하는 **URL**, 클라이언트가 어떤 HTTP 버전으로 말하고 있는지 서버에 알려주는 **HTTP 버전**도 포함
- 응답줄
    - 응답 메세지는 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려준다.
    응답 메세지의 시작줄은 혹은 응답줄에는 응답 메세지에 쓰인 **HTTP 버전** , **숫자로 된 상태코드** , **상태코드 텍스트** 들어있다.

## 3.3 메서드

모든 서버가 모든 메서드를 구현하지는 않는다

### 3.3.1 안전한 메서드 Safe Method

`GET`과 `HEAD` 메서드는 안전하다고 할 수 있음

why? HTTP 요청의 결과로 서버에 어떤 작용도 없음

안전한 메서드가 서버에 작용을 유발하지 않는다는 보장은 없지만 안전한 메서드의 목적은, 서버에 어떤 영항을 줄 수 있는 안전하지 않는 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 HTTP 애플리케이션을 만들 수 있도록 하는 것 에 있다

### 3.3.2 GET

GET메서드는 가장 흔히 쓰이는 메서드다. 주로 서버에게 리소스를 달라고 요청할 때 쓰인다.

### 3.3.3 HEAD

HEAD 메서드는 정확히 GET처럼 행동하지만, 서버는 응답으로 헤더만 돌려주고 엔티티 본문은 결코 반환하지 않는다.

- 리소스를 가져오지 않고도 그에 대해 무엇인가(타입이라거나)를 알아 낼 수 있다.
- 응답의 상태 코드를 통해, 개체가 존재하는지 확인 할 수 있다.
- 헤더를 확인하여 리소스가 변경되었는지 검사 할 수 있다.

### 3.3.4 PUT

PUT메서드의 의미는, 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 체하는 것

### 3.3.5 POST

POST 메서드는 서버에 입력 데이터를 전송하기 위해 설계

### 3.3.6 TRACE

클라이언트가 어떤 요청 → 방화벽, 프락시, 게이트웨이 등의 애플리케이션을 통과하면서 original HTTP 요청을 수정할 수 있는 기회가 있음

so TRACE 메서드는 **클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려줌**

- 목적지 서버에서 loopback 진단을 시작 → 요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 돌려줌

주로 진단을 위해 사용. 요청이 의도한 요청/응답 연쇄를 거쳐가는지 검사.. 또한 프록시나 다른 애플리케이션들이 요청에 어떤 영향을 미치는지 확인해보기 좋은 도구임

- 진단을 위해 사용할 때는 괜찮지만 대신 중간 애플리케이션이 서로 다른 메서드를 사용한 요청들을 일관되게 다룬다고 가정하는 문제 존재 → 실제로는 HTTP 애플리케이션은 메서드에 따라 다르게 동작함
    - e.g. 프락시는 POST요청을 바로 서버로 통과 시키는 반면 GET 요청은 웹 캐시와 같은 다른 HTTP 애플리케이션으로 전송
    - TRACE는 메서드를 구별하는 메커니즘 미제공. 따라서 TRACE 요청을 어떻게 처리할 것인지에 대해서는 일반적으로 중간 애플리케이션이 결정

### 3.3.7 OPTIONS

OPTIONS 메서드는 웹 서버에게 여러 가지 종류의 자원 범위에 대해 물어본다.

서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어 볼 수 있다.

### 3.3.8 DELETE

DELTE 메서드는 서버에게 요청 URL로 지정한 리소스를 삭제 요청한다.

그러나 클라이언트는 삭제가 수행되는것을 보장하지 못한다.

### 3.3.9 확장 메서드

확장 메서드는 HTTP/1.1 명세에 정의되지 않은 메서드다.

개발자들에게 그들의 서버가 구현한 HTTP 서비스의 서버가 관리하는 리소스에 대한 능력을 확장하는 수단을 제공한다.

## 3.4 상태 코드

상태코드는 클라이언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공

### 3.4.1 100-199: 정보성 상태 코드

정보성 상태 코드는 HTTP/1.1에서 도입

| 상태코드 | 사유구절 | 의미 |
| --- | --- | --- |
| 100 | Continue | 요청의 시작 부분 일부가 받아짐, 클라이언트는 나머지를 계속 보내야함. |
| 101 | Switching Protocols | 클라이언트가 Upgrade헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음을 의미 . |

100 Continue는 HTTP 클라이언트 애플리케이션이 서버에 엔티티 본문을 전송하기 전에 그 엔티티 본문을 서버가 받아 들일것인지 확인할때, 그 확인 작업을 **최적화**하기 위한 의도로 도입된 것

- 클라이언트와 100 continue
    - 만약 클라이언트가 엔터티를 서버에 보내려고 하고, 그 전에 100 응답을 기다리고자 하면 클라이언트는 값을 100-continue로 하는 Expect 요청 헤더를 보낼 필요 있음
    - 만약 안보낼거면 100-continue Expect 헤더 보내지 말아야함. 엔터티를 보낼 것이라고 생각한 서버가 혼란스러워짐
    - 계속 기다리는 것이 아니라 타임아웃 후에 클라이언트는 그냥 엔터티를 보내야함
    
    → 서버가 다루거나 사용할 수 없는 큰 엔터티를 서버에게 보내지 않으려는 목적으로만 사용
    
- 서버와 100 continue
    - 클라이언트로부터 100-continue Expect 헤더가 포함된 요청을 받으면 100 Continue 응답 혹은 에러코드로 답해야함
    - 100 Continue 응답을 받을 것을 의도하지 않은 클라이언트에게 100 상태코드 보내서는 안됨
    - 100 응답을 보내기전에 엔터티의 일부 혹은 전체를 수신했다면 상태코드 보낼 필요 없음 → 클라이언트가 이미 계속 전송하기로로 결정했으니까

### 3.4.2 200-299: 성공 상태 코드

클라이언트가 요청을 보내면, 그 요청은 대게 성공한다.

서버는 대응하는 성공을 의미하는 상태 코드의 배열을 갖고 있으며, 각각 다른 종류의 요청에 대응

| 상태코드 | 사유구절 | 의미 |
| --- | --- | --- |
| 200 | OK | 요청은 정상적이고, 엔티티 본문은 요청된 리소스에 포함하고 있다. |
| 201 | Created | 서버 개체를 생성하라는 요청(예: PUT)을 위한것. 서버는 상태코드를 보내기전에 반드시 객체를 생성해야함 |
| 202 | Accepted | 요청은 받아들여졌으나 서버는 아직 그에 대한 어떤 동작도 수행하지 않았으며 서버가 완료한다는 보장도없음. |
| 203 | Non_Authoriative Information | 엔터티 헤더에 들어있는 정보가 원래 서버가 아닌 리소스의 사본에서 왔다. |
| 204 | No Content | 응답 메세지는 헤더와 생태줄을 포함하지만 엔티티 본문은 포함하지 않는다. |
| 205 | Reset Content | 주로 브라우저를 위해 사용되는 또 하나의코드, 브라우저에게 현재 페이지에 있는 HTML 폼에 채워진 모든값을 비우라는 의미 |
| 206 | Partical Content | 부분 혹은 범위 요청이 성공했다. |

### 3.4.3 300-399: 리다이렉션 상태 코드

리다이렉션 상태 코드는 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공

리다이렉션 상태 코드중 일부는 리소스에 대한 애플리케이션의 로컬 복사본이 원래 서버와 비교했을 때 유효한지 확인하기 위해 사용

| 상태코드 | 사유구절 | 의미 |
| --- | --- | --- |
| 300 | Multiple Choices | 클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청했을 경우 그 리소스의 목록을 함꼐 반환함. 사용자는 이중에서 택함. |
| 301 | Moved Pemanently | 요청한 URL이 옮겨졌을 때 사용한다. 응답은 Location 헤더에 혀재 리소스가 존재하고 있는 URL을 포함해야함. |
| 302 | Found | 301과 같음. 그러나 Location헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야함. |
| 303 | See other | 클라이언트에게 리소스를 다른 URL에서 가져와야 한다고 말해주기 위해 쓰임. |
| 304 | Not Modified | 클라이언트가 GET과 같은 조건부 요청을 보냈고 그 리소스가 최근에 수정된 일이 없을떄 쓰임. |
| 305 | Use Proxy | 리소스가 반드시 프락시를 통해 접근되야함을 나타냄. |

### 3.4.4 400-499: 클라이언트 에러 상태 코드

클라이언트는 서버가 다룰 수 없는 무언가를 보낸다.

잘못 구성된 요청 메시지 같은 것이 있을수 있으며, 가장 흔한 것은 존재하지 않는 URL에 대한 요청이다.

| 코드 | 사유구절 | 의미 |
| --- | --- | --- |
| 400 | Bad Request | 클라이언트가 잘못된 요청을 보냈다고 말해준다. |
| 401 | Unautorized | 리소스를 얻기전에 클라이언트에게 스스로를 인증하라고 요구하는 내용의 응답을 적절한 헤더와 함께 반환. |
| 403 | Forbidden | 요청이 서버에 의해 거부되었음을 알려주기위해 사용. 그러나 이코드는 보통 서버가 거절의 이유를 숨길때 주로 사용함. |
| 404 | Not Found | 서버가 요청한 URL을 찾을 수 없음을 알려주기 위해 사용함. |
| 405 | Method Not Allowed | 요청한 URL에 대해 지원하지 않는 메소드로 요청받았을때 사용함. |
| 408 | Time Out | 클라이언트 요청을 완수하기에 시간이 너무 많이 걸리는 경우에 사용함. |
| 409 | Contifict | 요청의 리소스에 대해 일으킬 수 있는 몇몇 충돌을 지칭하기 위해 사용. |
| 410 | Gone | 404와 비슷하나 리소스를 갖고 있다는 점이 다르다. 주로 웹사이트를 유지보수하면서 서버 관리자가 클라이언트에게 리소스가 제거 된 것을 알려주기 위해 사용 |

### 3.4.5 500-599: 서버 에러 상태 코드

클라이언트가 올바른 요청을 보냈음에도 서버 자체에서 에러가 발생할 수 있다.

이것은 클라이언트가 서버의 제한에 걸린 것 일수 있고 혹은 게이트웨이 리소스와 같은 서버의 보조 구성요소에서 발생한 에러일 수 도 있다.

| 상태코드 | 사유구절 | 의미 |
| --- | --- | --- |
| 500 | Internal Server Error | 서버가 요청을 처리 할 수 없게 만드는 에러를 만났을 때 사용 |
| 501 | Not Implemented | 클라이언트가 서버의 능력을 넘는 요청을 했을때 사용 |
| 502 | Bad Gateway | 프락시나 게이트웨이처럼 행동하는 서버가 그 요청 응답 연쇄에 있는 다음 링크로부터 가짜 응답에 맞닥뜨렸을때. |
| 503 | Service Unavaliable | 현재는 서버가 요청을 처리해줄 수 없지만 나중에는 가능함을 의미할때 사용. |
| 504 | Gateway Timeout | 404와 비스하지만 프락시에서 온 응답이라는 점이 다름. |
| 505 | HTTP Version Not Supported | 서버가 지원 할 수 없거나 지원하지 않으려고 하는 버전의 프로토콜 된 요청을 받았을때 사용. |

## 3.5 헤더

헤더와 메서드는 클라이언트와 서버가 무엇을 하는지 결정하기 위해 함께 사용된다.

헤더에는 특정 종류의 메세지만 사용 할 수 있는 헤더, 더 일반 목적으로 사용 할 수 있는 헤더, 그리고 응답과 요청 메세지 양쪽 모두에서 정보를 제공하는 헤더가 있다.

- 일반 헤더
    - 요청과 응답 양쪽에 모두 나타낼 수 있는 헤더
    - e.g. `Date` 헤더 → 메시지가 만들어진 일시
- 요청 헤더
    - 요청에 대한 부가 정보를 제공하는 헤더
    - e.g. `Accept: */*` → 서버에게 클라이언트가 자신의 요청에 대응하는 어떤 미디어 타입도 받아들일 것임을 의미
- 응답 헤더
    - 응답에 대한 부가정보를 제공하는 헤더
    - e.g. `Server:Tiki-Hut/1.0` → 클라이언트에게 어떤 서버와 대화하고 있는지 알려줌
- 엔터티 헤더
    - 본문 크기와 콘텐츠, 혹은 리소스 그 자체를 서술하는 헤더
    - e.g. `Content-Type` 헤더 → 보내는 자원의 형식을 명시하기 위해 헤더에 실리는 정보
- 확장 헤더
    - 애플리케이션 개발자들에 의해 만들어졌지만 아직 승인된 HTTP 명세에는 추가되지 않은 비표준 헤더
