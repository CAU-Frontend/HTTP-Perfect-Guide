# 🔒 HTTP 완벽 가이드 13장(다이제🍪스트 인증) 🔒

기본 인증은 편리하고 유연하지만 안전하지 않음
개인정보를 평문으로 전송, 메시지 보호 시도 X
base-64 인코딩 정도? => 해독 매우 쉬움

이를 막기 위해 기본 인증과 호환되는 '🍪스트' 인증이 개발

## 다이제스트 인증

1. 개인정보를 네트워크 연결을 통해 평문으로 전송하지 않음
2. 인증 체결을 가로채서 재현하려는 악의적 트래픽 차단
3. 구현에 따라 메시지 내용 위조 방지
4. 상용화된 형태의 공격 방지

개인정보 자체를 보호하는 것 => 보호를 제공하는 것은 아님

- 요청 응답 외의 다른 부분에서는 가로채기 가능
- TLS나 HTTPS보다 안전한 프로토콜이 아님

## 개인정보 보호를 위한 요약 사용

다이제스트 인증에서 가장 중요하게 여기는 것은 개인정보를 네트워크를 통해 전송하지 않는 것

- 개인정보 대신 클라이언트는 fingerpint(지문)이나 digest(요약)을 전송
- 서버와 클라이언트가 모두 평문을 알고 있기 때문에 받은 지문||요약과 서버가 계산한 지문||요약이 일치하는 확인하는 방식으로 인증

## 단방향 요약

다이제스트(요약)은 단방향 함수로 동작 ???? 뒤에서 설명
일반적으로 입력 가능한 무한 가지의 모든 입력값들을 유한한 범위의 압축으로 변환 ???? 뒤에서 설명

MD5, SHA - 요약 함수 === 해시 함수 === 암호 체크섬

### 단방향 함수?

- 평문을 해시하는건 가능하지만 해시값을 복호화는 불가
- 고기를 갈아 다짐육을 만드는건 가능하지만 다짐육을 보고 어떤 부위의 고기였는지 알아낼 수 없음

### 무한가지의 모든 입력값을 유한한 범위로 압축?

- 비밀번호가 6720자여도 해시값은 N자로 고정
- 입력은 무한하지만 출력은 항상 N자 고정
- 무한을 유한으로 압축하기 때문에 이론적으로 서로 같은 해시값이 생성될 수 있음 === 충돌
- 하지만 확률이 높지 않음

그래서 '요약'이라고 표현 다이제스트 === 해시값

## 재전송 방지를 위한 nonce

요약을 가로채서 서버로 재전송하는 replay attack 방지를 위해 서버가 클라이언트에게 nonce를 전송

nonce를 개인정보에 섞어 nonce가 변경될 때마다 해시값도 변경

? 해시값을 탈취했다면 해당 해시값을 전송하여 인증을 통과하는 재전송 공격(replay attack)발생 가능

그렇기 때문에 딱 1번만 사용 가능한 nonce라는 임의의 비밀번호를 섞어서 해당 nonce가 포함된 요청만을 처리하고, 1번 처리된 nonce는 재전송 되어도 처리가 되지 않도록 구현하는 것

### 다이제스트 인증 과정

1. 서버가 nonce 생성
2. 서버는 nonce를 인증요구 메시지에 담아 서버가 지우너하는 알고리즘 목록과 함께 전송
3. 클라이언트는 알고리즘을 선택하여 해시값을 생성
4. 클라이언트가 해시값을 서버에게 전송, 인증을 원한다면 nonce도 함께 전송
5. 서버는 해시값을 계산한 다음 클라이언트에서 받은 해시값과 일치하는지 확인
6. 클라이언트가 서버에게 클라이언트 nonce를 가지고 인증을 요구했다면 클라이언트 해시 생성
7. 새로운 nonce 생성하여 클라이언트로 전송

## 해시 알고리즘 입력 데이터

해시는 다음 3 요소로부터 계산

1. 단방향 해시 함수 H(d) & 해시 함수 KD(s, d) => s는 비밀, d는 데이터
2. 개인정보 등 보안 정보를 담고 있는 데이터 => A1
3. 요청 메시지의 비밀이 아닌 속성을 담고 있는 데이터 => A2

### 보안 데이터(A1)

A1은 사용자 이름, 비밀번호, 보호 영역, nonce와 같은 비밀 보호 정보로 이루어짐

A1은 비밀 보호 정보만 관련된 데이터

해시 계산을 위해 사용

**MD5**
모든 요청마다 단방향 해시를 실행하는 알고리즘

A1 = <이름>:<영역>:<비밀번호>

**MD5-sess**
사용자 이름, 영역, 비밀번호에 대한 해시를 계산한 결과 뒤에 현재 nonce와 클라이언트 nonce를 붙인 것이 A1

A1 = MD5(<이름>:<영역>:<비밀번호>):<nonce>:<CLIENTnonce>

MD5 해시에서 nonce를 추가한 것이 세션 기반 MD5-sess 방식

### 메시지 데이터(A2)

url, 메서드, 엔터티 본문 등 메시지 자체

## 요약 알고리즘 전반

H, KD, A1, A2를 사용해서 해시 산출

BUT 읽기만 해라 사실 안읽어도 된다.

## 다이제스트 인증 세션

www-authenticate 인증 요구에 대한 클라이언트 응답은 서버에 대한 인증 세션을 시작

인증 세션은 클라이언트가 다른 서버로부터 또다른 인증 요구를 받을 때까지 지속
즉, 클라이언트는 인증과 관련된 정보를 기억해야 함

## 사전 인가

일반적인 인증에서는 트랜잭션이 완료되기 전에 인증 사이클 필요

사전 인가가 가능하면 메시지 횟수 감소

### 사전 인가란?

기본 인증 - 사용자가 사이트에 한 번 인증하면 해당 사이트 URL에 대한 다음 요청에는 올바른 Authorization 헤더 전송 가능

해시 인증 - nonce가 없으면 클라이언트는 Authorization 헤더를 알 수 없음

인증 요구를 기다리지 않고 nonce를 취득하는 방법?

- 다음 nonce 미리 생성하여 인증 성공 헤더에 담아서 전송
- 제한된 nonce 재사용
- 동기화된 nonce 생성

## nonce 선택

nonce는 구현 의존적
개발자맴

## 상호 인증

클라이언트에서도 서버를 인증할 수 있도록 해시 인증 확장
보안 성능 증가

## 보호 수준 향상

qop 필드는 클라이언트와 서버가 어떤 보호 기법을 어느 정도 수준으로 사용할 것인지 협상 가능하게 함

모든 현대적인 요약 구현은 qop 옵션을 지원해야 한다.

auth : 인증
auth-int : 인증 및 메시지 무결성 보호

💡 qop?

- Quality of Protection
- 해시 인증에서 보안 수준을 선택하는 옵션

### 메시지 무결성 보호

qop = auth-int 일 경우
엔터티 본문의 해시에 대해 무결성 계산

### 해시 인증 헤더

인증 프로토콜은 모두 www-authenticate 헤더에 담겨 전달되는 인증 요구와 Auth 헤더에 담겨 전달되는 인가 응답을 포함

해시 인증 헤더는 굉장히 복잡 부록 F를 확인하라. 난 안했다.

## 🔒 실제 상황 🔒

### 다중 인증 요구

서버는 한 리소스에 대해 여러 인증 요구 가능

### 에러 처리

인증 실패 시 400 Bad Request 반환 및 로그 기록

### 보호 공간

기본인증은 한 URI의 모든 하위 경로까지 같은 보호 공간으로 처리
해시인증은 보호 공간을 보다 엄밀하게 설정 가능

### URL 재생성

프록시가 리소스 변경없이 URI를 다시 쓰기도 함
이와 동시에 해시 인증은 URI 값의 무결성을 검사하므로 해시 인증 실패 가능성 有

### 캐시

공유 캐시가 인증 헤더를 포함한 요청과 그에 대한 응답을 받은 경우, 다음 두 캐시 컨트롤 지시자 중 하나가 응답에 존재하지 않는 한 다른 요청에 대해 응답 반환 불가

- 서버 응답이 public 캐시 컨트롤 지시자를 포함한 경우에는 이후 요청에 대해 응답 반환 가능

## 🔒 보안 실제 상황 🔒

### 헤더 부당 변경

양종단 암호화나 헤더에 대한 전자 서명으로 헤더 변경을 방지 가능

### replay attack

replay attack을 완벽하게 방지하는 방법은 트랜잭션마다 유일무이한 nonce를 사용하는 것

그럼 왜 그렇게 안하지?

- 서버 부하
- 만료 관리 어려움
- 재시도 문제

등등

그래서 완벽한 방지보다는 현실적인 방지를 진행

### 다중 인증

가능한 가장 강력한 인증 제도를 선택하도록 설정

### 사전 공격

복잡한 비밀번호 사용하기 or 비밀번호 만료 정책으로 방지 가능

💡 보안학과가 아닌 인간을 위한 사전 공격 용어 설명

- 비밀번호로 쓰일만한 수백만 개의 패턴을 무차별 대입으로 뚫어내는 것
- jay123, 123jay, jay0324, 0324jay, jayjayjay, jaaaaaaaaaaay 를 배열에 담고 for문으로 비밀번호 input에 다 입력해보는 그런거

# 🔒 HTTP 완벽 가이드 14장(보안 HTTP)🔒

웹은 중요한 트랜잭션을 위해 HTTP와 디지털 암호화 기술을 결합한 안전한 방식이 필요

## HTTPS

HTTPS는 HTTP 를 안전하게 만드는 방식 중에 가장 널리 사용되는 것

HTTPS를 사용하면 모든 HTTP 요청과 응답 데이터가 네트워크로 보내지기 전에 암호화

HTTPS는 HTTP 하부(TCP 위, HTTP 아래)에 전송 레벨 암호보안 계층을 제공함으로써 동작

어려운 인코딩 및 디코딩 작업의 대부분이 SSL 라이브러리에서 이뤄지기 때문에 HTTPS를 사용하기 위해 웹 클라이언트와 서버가 프로토콜을 처리하는 로직을 크게 변경할 필요 없음

## 디지털 암호학

용어 정리

암호 - 평문 메시지를 인코딩한 것
키 - 암호의 동작을 변경하는 숫자로 된 매개변수
대칭키 - 인코딩과 디코딩을 같은 키를 사용하는 알고리즘
비대칭키 - 서로 다른 키를 사용하는 알고리즘
디지털 서명 - 메시지가 위조되었는지 증명하는 체크섬
디지털 인증서 - 신뢰할만한 조직에 의해 서명되고 검증된 신원 확인 정보

## HTTPS의 세부사항

HTTPS는 HTTP 프로토콜에 대칭, 비대칭 인증서 기반 암호 기법의 강력한 집합을 결합한 것!

### 개요

HTTPS는 보안 전송 계층을 통해 전송되는 HTTP
TCP로 보내기 전에 암호화를 진행하는 보안 계층으로 전송

### HTTPS 스킴

URL 스킴에 http 대신 https를 접두사로 사용

💡스킴 기억나시나요?
스킴 - http
호스트 - naver.com
경로 - login

http://naver.com/login === URL

### 보안 전송 셋업

HTTPS에서의 절차는 SSL 보안 계층으로 인해 복잡성 증가
클라이언트는 먼저 웹서버의 443 포트 연결
TCP 연결이 되면 클라이언트와 서버는 SSL 핸드셰이크

TCP 핸드셰이크 완료 => SSL 핸드셰이크 완료 => 클라이언트는 요청 메시지를 보안 계층에 전송 가능
TCP로 보내기 전에 암호화

### 서버 인증서

보안 HTTPS 트랜잭션은 항상 서버 인증서 요구
사용자가 서버에 개인정보 등을 보내기 전에 서버를 얼마나 신뢰할 수 있는지 평가 가능 === 상호인증

## 리얼 HTTPS 클라이언트

SSL은 복잡한 바이너리 프로토콜, SSL 클라이언트와 서버 프로그래밍을 쉽게 만들어주는 오픈 소스 라이브러리가 존재

EX)
OpenSSL - SSL의 가장 상용화된 오픈 소스

https로 만들어주는 인증서 발급

네부캠에서 6기 어떤 분이 발급 받아서 https 통신으로 만들어보는 경험을 해보라고 함. 안해봄

## 프록시를 통한 보안 트래픽 터널링

보안을 위한 프록시를 설치하고, 방화벽 라우터가 트래픽 교환을 허락한 유일한 장치이므로 프록시를 통해 접근

암호화하면 프록시는 http 헤더를 읽지 못하여 암호화된 요청을 다룰 수 없음

이를 해결하기 위한 것이 HTTPS SSL 터널링

1. 프록시에게 연결하고자 하는 호스트와 포트 설정
2. 프록시가 읽을 수 있도록 암호화 전에 평문 전송
3. 클라이언트와 서버 사이에서 데이터가 직접 오갈 수 있는 터널 생성

# 🔒 HTTP 완벽 가이드 15장(엔터티와 인코딩) 🔒

HTTP 메시지가 컨테이너라면 HTTP 엔터티는 메시지의 실질적인 화물

엔터티 본문에는 가공되지 않은 데이터를 담고 헤더에서 데이터 의미에 대해 설명

## 엔터티 헤더

- Content-Type : 엔터티에 의해 전달된 객체의 종류
- Content-Length : 전달되는 메시지의 길이나 크기
- Content-Language : 전달되는 객체와 가장 잘 대응되는 자연어
- Content-Encoding : 객체 데이터에 대해 행해진 변형(압축 등)
- Content-Location : 요청 시점을 기준으로, 객체의 또 다른 위치
- Content-Range : 만약 이 엔터티가 부분 엔터티라면, 이 헤더는 이 엔터티가 전체에서 어느 부분에 해당하는지 정의한다
- Content-MD5 : 엔터티 본문의 콘텐츠에 대한 체크섬
- Last-Modified : 서버에서 이 콘텐츠가 생성 혹은 수정된 날
- Expires : 이 엔터티 데이터가 더 이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각
- Allow : 이 리소스에 대해 어떤 요청 메서드가 허용되는지
- ETag : 이 인스턴스에 대한 고유한 검사기. 엔터티 헤더는 아지미나 엔터티와 관련된 많은 동작을 위해 중요한 헤더
- Cache-Control : 어떻게 이 문서가 캐시될 수 있는지에 대한 지시자

Content-Type, ETag, Allow, Cache-Control 등을 자주 봤던 것 같음

💡 ETag 기억 나시나요?

리소스의 버전
캐시에서 해당 리소스가 최신 업데이트된 버전인지 확인하던 그거

## Content-Length

메시지 엔터티 본문의 크기를 바이트 단위로 나타냄
인코딩 되어있으면 인코딩된 엔터티 길이
필수 정보
왜? 모든 데이터가 왔는지 확인하기 위해

## 잘림 검출

Content-Length로 메시지의 끝을 확인
포함되지 않았다면 에러 발생
없으면 캐싱도 하지 않음

## 잘못된 Content-Length

길이 정보가 잘못되면 큰 피해가 발생
이를 방지하기 위해 탐지하고 교정을 시도하도록 구현

## Content-Length와 keep-alive

지속 커넥션을 위해 필수적
길이를 기준으로 커넥션을 끊기 때문에 메시지의 끝을 인식하지 못하고 제대로된 데이터를 받아오지 못하는 상황 발생

🚨 트러블슈팅

엔터티 본문을 서버에서 buffer에 담으면 Content-length와 정확히 일치 but 배열에 담으면 길이가 달라짐

why?
버퍼 = 바이트 단위로 저장
배열 = 문자 단위로 저장

배열에 담았다가 메시지가 다 오지 않았는데 이미 배열에 담긴 요소의 길이가 Content-length와 일치하여 연결을 끊어버리는 상황 발생

버퍼로 변경하여 해결

## Content-Type

엔터티 본문의 MIME 타입을 기술

https://cjy3458.tistory.com/48 참고

## 콘텐츠 인코딩

### 과정

1. 서버가 원본과 헤더를 포함한 응답 메시지 생성
2. 콘텐츠 인코딩 서버가 인코딩된 메시지 생성, Content-Encoding 헤더를 인코딩된 메시지에 추가하여 클라이언트에서 디코딩 가능하도록 설정
3. 클라이언트는 메시지를 디코딩하여 원본 취득

## Accept-Encoding 헤더

서버에서 지원하는 인코딩 알고리즘 목록을 헤더를 통해 전달

해당 헤더가 없다면 세상 모든 인코딩 알고리즘을 계산할 수 있다는 것으로 간주

## 전송 인코딩과 청크 인코딩

콘텐츠 인코딩이 엔터티 인코딩이라면 전송 인코딩은 메시지의 인코딩

### Transfer-Encoding 헤더

전송 인코딩을 제어하고 서술하기 위해 정의된 헤더

안전한 전송을 위해 어떤 인코딩 알고리즘이 메시지에 적용되었는지 수신자에게 알려줌

### 청크 인코딩

전송 인코딩 방식 중 하나

1. 메시지를 일정 크기의 청크로 쪼갬
2. 각 청크를 순차적으로 전송
3. 청크 인코딩을 사용하면 메시지의 Content-Length를 알 필요가 없어짐(거의 유일하게 Content-Length 헤더가 없어도 되는 경우!)
4. 마지막 청크는 0을 보내서 메시지가 끝났음을 알 수 있음(길이 헤더 없이도)

### 전송 인코딩

1. 반드시 chunked를 포함 유일한 예외는 메시지가 커넥션의 종료로 끝나는 경우
2. 청크 전송 인코딩이 사용되면 마지막 전송 인코딩이 존재해야 함
3. 청크 전송 인코딩은 반드시 메시지 본문에 한 번 이상 적용

....

### 델타 인코딩

만료된 웹 페이지에 대해 새 페이지 전체를 보내는 대신 변경된 부분만 서버가 보낸다면 클라이언트는 더 빨리 페이지를 얻을 수 있음

ex)
const users_v1 = [
{ id: 1, name: "Jay", age: 25 },
{ id: 2, name: "Alice", age: 30 },
{ id: 3, name: "Bob", age: 35 }
];

const users_v2 = [
{ id: 1, name: "Jay", age: 25 },
{ id: 2, name: "Alice", age: 31 }, // 30 → 31
{ id: 3, name: "Bob", age: 35 }
];

인코딩 시 변경된 부분만을 인코딩하여 전송하는 것

...React?
