# 보안 HTTP

### HTTP를 안전하게 만들기

HTTP 보안 요구사항들

1. 서버인증 - 클라이언트는 자신이 위조된 서버가 아닌, 진짜와 이야기하고 있음을 알 수 있어야 한다.
2. 클라이언트 인증 - 서버는 자신이 가짜가 아닌 진짜 사용자와 이야기하고있음을 알 수 있어야 한다.
3. 무결성 - 클라이언트와 서버는 그들의 데이터가 위조되는 것으로부터 안전해야함
4. 암호화 - 도청에 대한 걱정 없이 대화.
5. 효율 - 저렴한 클라이언트나 서버도 이용할 수 있도록 알고리즘은 충분히 빨라야함
6. 편재성 - 프로토콜은 거의 모든 클라이언트와 서버에서 지원되어야한다.
7. 관리상 확장성 - 누구든 어디서든 즉각적인 보안 통신을 할 수 있어야함
8. 적응성 - 현재 알려진 최선의 보안방법을 지원해야함
9. 사회적 생존성 - 사회의 문화적, 정치적 요구를 만족시켜야 한다.

### HTTPS

HTTP를 안전하게 하는 방식 중 가장 인기 있는것
넷스케이프에서 개척했다고하네요~

모든 응답/요청 데이터는 네트워크로 보내지기전에 암호화됨
SSL 혹은 TLS를 통해서 구현함

## 디지털 암호학

패스.

# HTTPS의 세부사항

보안 전송 계층을 통해 전송되는 HTTP
암호화되지 않은 HTTP를 TCP를 통해 전 세계의 인터넷 곳곳으로 보내는 대신에 먼저 암호화함

## HTTPS스킴

url 스킴을 통해 확인가능~
브라우저는 리소스에 대한 트랜젝션 수행을 요청받으면 URL스킴을 검사함
http인경우는 80포트
https인 경우는 443포트로 연결.
SSL핸드셰이크를 하고, 암호화된 HTTP명령이 뒤로 이어짐

SSL 트래픽은 바이너리 프로토콜이기때문에, HTTP와는 완전히 다름.
80으로 도착하면, 대부분의 브라우저는 SSL트래픽을 잘못된 HTTP로 해석하고 커넥션을 닫음.

## 보안 전송 셋업

1. 443 포트로 TCP커넥션 수립
2. SSL보안 매개변수 핸드셰이크
3. SSL을 통해 보내진 HTTP 요청/TCP를 통해 보내진 암호화된 요청
4. SSL을 통해 보내진 HTTP 응답/TCP를 통해 보내진 암호화된 응답
5. SSL닫힘 통지
6. TCP 커넥션 닫힘

## SSL 핸드셰이크

암호화된 HTTP 메시지를 보낼 수 있게 되기전에 클라와 서버는 핸드셰이크를 해야함
아래 일이 일어나야함.

1. 프로토콜 버전 번호 교환
2. 양쪽이 알고 있는 암호 선택
3. 양쪽 신원 인증
4. 채널 암호화를 위한 임시세션키 생성

### 간소화된 절차

1. 클라이언트가 암호후보를 보내고 인증서를 요구함
2. 서버는 선택된 암호화 서버의 인증서를 보냄
3. 클라이언트가 비밀정보를 보냄. 클라와 서버는 키를 생성함.
4. 클라와 서버는 서로에게 암호화를 한다고 말해줌

### 서버 인증서

트랜젝션이 일어나는 그 조직이 맞는지 확인하는 용도
서버 인증서는 조직의 이름, 주소, 서버 DNS도메인 이름, 외의정보를 보여주는 인증서.
RSA방식으로 인증된 인증서를 말함.

### 사이트 인증서 검사

SSL 자체는 인증서 검증을 요구하지는 않으나
보통 웹브라우저는 기본적인 검사를 하고, 결과를 더 철저한 검사를 할 수 있는 방법과 함께
사용자에게 알려줌

### 인증 검사 알고리즘

1. 날짜 검사 - 인증서의 시작 및 종료일을 검사 => 실패시 오류
2. 서명자 신뢰도 검사 - 모든 인증서는 서버를 보증하는 어떤 인증 기관에 의해 서명되어있음. 이 인증 기관자체가 신뢰할 수 없는 경우도 있는데, 이 경우 브라우저는 보통 경고를 보여줌.
3. 서명검사 - 서명 기관이 믿을만하다고 판단하면, 브라우저는 서명기관의 공개키를 서명에 적용하여 그의 체크섬과 비교함으로써 인증서의 무결성을 검사함
4. 사이트 신원검사 - 타 인증서를 복사하거나 트래픽 가로채기를 방지하기위해서 인증서 도메인 이름이 서버의 도메인 이름과 동일한지 검사함 -> 다르면 연결 끊어야함

### 가상 호스팅 인증서

위의 사이트 신원검사에서 인증서도메인이 달라지므로 복잡함
브라우저에서 경고가 발생됨

## 프록시를 통한 보안 트래픽 터널링

프록시를 사용하는 경우의 HTTPS의 문제.
프록시는 중간에 있어서 암호화된 HTTPS 통신의 HTTP헤더를 읽을수가 없음
못읽으면 어디로 보내야하는지 모름;

### SSL 터널링

1. HTTPS트널링 프로토콜을 통해 클라는 프록시에게 자신이 연결하고자 하는 호스트와 포트를 말해줌
2. HTTP는 CONNECT라는 확장 메서드를 통해 평문 종단 정보를 전송함
3. 클라와 서버 사이에서 데이터가 직접 오갈 수 있게 해주는 터널을 만듦

```
CONNECT home.sit:443 HTTP/1.0
User-agent: Mozila/1.1N

SSL 암호화 데이터...
```

클라는 이 메시지를 보내고 프록시로부터 응답을 기다림
프록시는 요청을 평가해서 그것이 유효하고, 커넥션을 허가 받았는지 확인후에는 서버로 연결하고
200 Connection Established 응답을 보냄

```
HTTP/1.0 200 Connection established
Proxy-agent: Netscape-Proxy/1.1
```

# 엔터티/인코딩

HTTP는 아래를 보장한다.

1. 객체는 올바르게 식별되므로 (Content-Type, Content-Languate) 브라우저나 다른 클라이언트는 콘텐츠를 바르게 처리할 수 있다.
2. 객체는 올바르게 압축이 해제된다. (Content-Length, Content-Encoding)
3. 객체는 항상 최신. (Cache.)
4. 사용자의 요구를 만족한다. (Accpet관련 헤더)
5. 네트워크 사이를 빠르고 효율적으로 이동 (범위요청, 델타인코딩, 데이터압축)
6. 조작되지 않고 온전하게 도착(전송 인코딩 헤더와 MD5체크)

## 메시지는 컨테이너, 엔터티는 화물

HTTP메시지를 컨테이너라고본다면, 엔터티는 실질적인 화물을 말함
엔터티 헤더

1. Content-Type : 엔터티에 의해 전달된 객체의 종류
2. Content-Length: 전달되는 메시지의 길이나 크기
3. Content-Language: 전달되는 객체와 가장 잘 대응되는 자연어
4. Content-Encoding: 객체 데이터에 대해 행해진 변형(압축)
5. Content-Location: 요청 시점을 기준으로, 객체의 또다른 위치
6. Content-Range: 이 엔터티가 부분 엔터티라면 이 헤던느 전체에서 어떤 부분에 해당하는지를 정의
7. Content-MD5: 본문 콘텐츠에 대한 체크섬
8. Last-Modified: 서버에서 이 콘텐츠가 생성/수정된 날
9. Expires: 이 엔터티 데이터가 더이상 신선하지 않은 것으로 간주되기 시작하는 날짜와 시각
10. Allow: 이 리소스에 대해 어떤 요청 메서드가 허용되는지
11. Etag: 이 인스턴스에 대한 고유한 검사기
12. Cache-Control: 이 문서가 어떻게 캐시될 수 있는지에 대한 지시자.

## 엔터티 본문

가공되지 않은 데이터만을 담고 있음.
다른 정보들은 모두 헤더에 담김
본문은 가공되지 않은 날 데이터라서 헤더를 통해 설명할 필요가 있다.
이 데이터는 ASCII 언어일수도, 이미지 데이터에 대한 binary 데이터일수도 있다.

### Content-Length

메시지 엔터티 본문의 크기를 바이트 단위로 나타냄
어떻게 인코딩 됐든 상관없이 크기를 표현함(gzip의 경우, 압축된 후의 크기를 표기)
이 헤더는 메시지를 청크 인코딩으로 전송하지 않는 이상, 엔터티 본문을 포함한 메시지에서는 필수적으로 있어야함.
서버 충돌로 인해 메시지가 잘렸는지 감시하고자 할떄와, 지속 커넥션을 공유하는 메시지를 올바르게 분할하고자 할때 필요하다.

#### 청크인코딩?

HTTP/1.1에서 응답 본문의 크기를 미리 알 수 없을 때, 데이터를 여러 개의 조각(청크)로 나누어 전송하는 방식
헤더에
Transfer-Encoding: chunked
로 표기

#### 메시지 잘림

Content-Length가 없다면 클라이언트는 커넥션이 정상적으로 닫힌 것인지 메시지 전송중에 서버에 충돌이 발생한 것인지 구분하지 못함
이는 특히 캐싱 프락시 서버에서 특히 취약함. **캐시가 잘린 메시지를 수신했으나 잘렸다고 인식하지 못하면, 캐시는 결함이 있는 콘텐츠를 저장하고, 계속 제공하게 될 수 있음**
따라서 보통 Content-Length헤더가 없는 HTTP본문은 잘 캐시 안한다고하네요~

#### 잘못된 Content-Length

잘못된 값을 담은 경우 빠진것 보다도 큰 피해를 유발할 수 있음

#### 지속 커넥션 관련

HTTP 커넥션은 TCP 위에서 동작
TCP의 특징:
• 바이트 스트림
• 메시지 경계 없음
• “이게 끝이다”라는 개념이 없음

#### 콘텐츠 인코딩

콘텐츠가 인코딩 된 경우, Content-Length의 크기는 원본 길이가 아니라 인코딩 된 본문의 길이를 말한다.

### 엔터티 본문 길이 판별을 위한 규칙

반드시 아래 순서대로 적용되어야 한다고 하네요~

1. 본문을 갖는 것이 허용되지 않는 HTTP메시지에 대해서는, 본문 계산을 위한 Content-Length 헤더가 무시됨. 이때는 부가정보에 불과하며, 실제 본문 길이를 서술하지 않음
2. Transfer-Encoding을 포함한 경우, 메시지가 커넥션이 닫혀서 먼저 끝나지 않는 이상 엔터티는 0바이트 청크로 불리는 특별 패턴으로 끝나야함.
3. 메시지가 Content-Length헤더를 갖는다면, Transfer-Encoding헤더가 존재하지 않는 이상 값으로 본문 길이를 담는다.
4. 메시지가 multipart/byteranges 미디어 타입을 사용하고 엔터티 길이가 별도로 정의되지 않았다면, 메시지의 각 부분은 각자가 스스로의 크기를 정의함.
5. 위 경우가 아니라면, 엔터티는 커넥션이 닫힐때 끝난다. 클라이언트는 클라이언트 메시지가 끝났다는 신호를 위하 커넥션을 닫을 수 없다.
6. HTTP/1.0호환을 위해 1.1 명세는 반드시 유효한 Content-Length 헤더도 갖고 있어야한다.

### 엔터티 요약

Content-MD5 -> 본문에 MD5 해싱 적용한 결과를 보냄
이는 전송 인코딩은 적용하지 않은 엔터티 본문에 대한 MD5를 담음
따라서 무결성 검사시에는 전송인코딩을 디코딩한 뒤에 그 엔터티 본문에 대해 MD5를 연산해서 비교해야함

### 미디어 타입과 차셋

Content-Type 헤더필드는 MIME타입을 기술함
전다로디는 데이터 매체의 기저 형식의 표준화된 이름임!
MIME타입은 `주미디어타입/부타입`으로 구성
text/html, text/plain, image/gif, image/jpeg

### 텍스트 메체를 위한 문장 인코딩

내용 유형을 더 자세히 지정하기위한 매개변수도 지원함
charset이 그것
`Content-Type: text/html, charset=iso-8859-4`

### 멀티파트 미디어 타입

멀티파트 이메일 메시지는 서로 붙어있는 여러 메시지를 포함.
하나의 메시지 바디 안에 여러개의 서로 다른 조각을 담기위한 포맷
boundary로 구분함
`Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryABC123`

```
------WebKitFormBoundaryABC123
Content-Type: text/plain

hello
------WebKitFormBoundaryABC123
Content-Type: image/png

(binary data)
------WebKitFormBoundaryABC123--
```

### 콘텐츠 인코딩

Content-Encoding을 통해 인코딩 정보를 확인하고, Content-Type에 맞게 디코딩을 진행함

### 콘텐츠 인코딩 유형

인코딩 알고리즘 유형 (무손실)

1. gzip : GNU zip 인코딩이 적용
2. compress: 유닉스 압축 프로그램인 compress가 실행되었음
3. deflate: zlib 포맷 압축
4. identity: 어떤 인코딩도 안했음. 기본값. 없는 경우 이것으로 간주됨

### Accept-Encoding

클라이언트가 요청시에 헤더에 담아서 서버에 이 인코딩에 맞게 달라고함
값이 없으면 클라이언트가 어떤 인코딩이든 받아들일 수 있는 것으로 간주함
q값으로 선호도 표기 가능

`Accept-Encoding: compress;q=0.5, gzip;q=1.0`
gzip이 더좋다는뜻~

## 전송 인코딩과 청크 인코딩

네트워크를 통해 전송되는 방법을 바꾸기 위해 메시지에 전송 인코딩을 적용함

### 안전한 전송

전송 인코딩은 안전한 전송에 초점을 맞춤.

일어날 수 있는 문제

1. 알수 없는 크기 - 생성하지 않고는 본문 크기를 알수가 없는데, 이걸 보내야할때
2. 보안 - 인코딩으로 보안처리를 하는경우 (요즘은 SSL로 처리)

### Transfer-Encoding

안전한 전송을 위해 어떤 인코딩이 메시지에 적용됐는지 수신자에게 알려준다.

#### TE

어떤 확장된 전송 인코딩을 사용할 수 있는지 서버에게 알려주기 위해 `요청 헤더`에 사용\

```
GET /new_product HTTP/1.1
...
TE: trailers, chunked
```

메시지와 메시지 끝에 트레일러가 오는 것을 받아들일수 있다는 뜻

#### 청크 인코딩

HTTP 1.1에 추가

본문이 아닌 메시지의 속성
메시지를 일정 크기의 청크 여럿으로 쪼개고, 이를 순차적으로 보냄
메시지를 보내기전에 전체 크기를 알 필요가 없어짐

gpt강 이건가? 해서 봤는데 **text/event-stream** 였음

#### 청크와지속 커넥션

클라와 서버 커넥션이 지속적이지 않다면, 클라는 자신이 읽고 있는 본문 크기를 알 필요가 없음.
지속커넥션에서의 청크 인코딩은 크기가 0인 청크로 본문이 끝났다는 것을 알림

### 전송 인코딩 규칙

1. 전송 인코딩의 집합은 반드시 chunked를 포함해야함, 유일한 예외는 메시지가 커넥션의 종료로 끝나는 경우
2. 청크 인코딩이 사용됐다면, 메시지 본문에 적용된 마지막 전송 인코딩이 존재해야함
3. 청크 전송 인코딩은 반드시 메시지 본문에 한번 이상 적용되어야한다.

## 캐시

| 구분        | 헤더              | 방향              | 역할                          |
| ----------- | ----------------- | ----------------- | ----------------------------- |
| 검증자      | ETag              | 서버 → 클라이언트 | 리소스의 버전 식별자          |
| 검증자      | Last-Modified     | 서버 → 클라이언트 | 리소스의 마지막 수정 시각     |
| 조건부 요청 | If-None-Match     | 클라이언트 → 서버 | ETag가 같으면 본문 불필요     |
| 조건부 요청 | If-Modified-Since | 클라이언트 → 서버 | 해당 시각 이후 변경 여부 확인 |

### 강한 검사기와 약한 검사기

강한 검사기: 언제나 인스턴스를 고유하게 식별함 ex) MD5해시값
약한 검사기: 인스턴스를 고유하게 식별하지 못하는 경우도 있음 ex) 수정시간

## 델타인코딩

정말 바뀐 부분만 얻고 싶다면? 에 대한 해답
전체 리소스를 보내는것이 아닌, 변경된 부분만 보내는 형태

클라는 자신이 가진 현재 버전에 델타를 적용하기 위하여 어떤 알고리즘을 알고 있는지 알려줘야함
서버는 자신이 클라이언트가 가진 버전을 갖고 있는지, 최신버전과 이전 버전의 델타를 계산할 것인지 체크해야함

1. A-IM 헤더를 통해 클라이언트가 요청시 제공(Accept-Instance-Manipluation)
2. 서버는 226 응답 코드를 사용하여, 응답
3. IM헤더, 새 Etag헤더, 델타 계산시 기준 문서의 ETag를 지정한 Delta-Base를 응답함

### A-IM 헤더의 값 종류

1. vcdiff : vcdiff알고리즘
2. diffe : 유닉스의 diff -e명령
3. gdiff
4. gzip
5. defalte
6. range: 범위선택에 대한 결과인 부분 콘텐츠
7. identit: identity 인스턴스 조작을 받아들일 의사가 있음을 말해주기위해 사용

=> 델타인코딩 구현시 서버는 반드시 클라이언트가 가지고 있던 이전 버전의 사본들 모두를 유지해야해서 디스크 공간 소비가 더 많아짐 (처음에 적어놓지...)

# 국제화

### 서버

국제 콘텐츠를 지원하기 위해 서버는 클라이언트에게 각 문서의 문자와 언어를 알려줌

Content-Type의 charset 매개변수와 Content-Languate 헤더를 통해 알려줌

### 클라이언트

Accept-Charset, Accept-Language를 통해 선호하는 인코딩 알고리즘과 언어를 알려줌
q인자를 통해 0~1사이의 선호도 전송가능

### 문자 집합과 HTTP

charset -> 글자를 비트, 비트를 글자로 변환하는 인코딩
charset 매개변수로 오는 값에 따라 변화되는 글자 체계가 달라짐 ex) ios-8859-6 은 아랍어다.

### 인코딩 동작 방식

[!image](https://velog.io/@he0_077/HTTP-%EC%99%84%EB%B2%BD-%EA%B0%80%EC%9D%B4%EB%93%9C-16%EC%9E%A5-%EA%B5%AD%EC%A0%9C%ED%99%94)

charset이 잘못되면 이상한 꺠진 글자를 보게되니 주의해야함~

### 다중언어 문자 인코딩에 대한 지침...

패스..

### URI 이스케이핑

예약어, 이스케이핑 잘해주어야 정보 손실 없이 페이지 제공가능
